local Players = game:GetService("Players")
local player = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local camera = workspace.CurrentCamera

-- ================= LOAD WINDUI =================
local WindUI = loadstring(game:HttpGet(
    "https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"
))()

-- ================= SET FONT (IMPORTANT) =================
-- WindUI text font
WindUI:SetFont("rbxasset://fonts/families/GothamSSm.json")

-- ================= CREATE WINDUI WINDOW =================
local Window = WindUI:CreateWindow({
    Folder = "XuanHub",
    Title = "XUAN HUB",
    Author = "by discord.gg/kaydensdens",
    Icon = "rbxassetid://103326199885496",
    Theme = "Dark",
    Size = UDim2.fromOffset(640, 480),
    Draggable = true,
    HasOutline = true,
    HideSearchBar = false,
    OutlineThickness = 3,
    Resizable = true,
    Transparent = true,
    User = {
        Enabled = true,
    },


})

Window:EditOpenButton({
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

-- Add version tag with FPS and Ping counter
local version = game.PlaceVersion -- Server version
local fps = 0
local ping = 0
local Stats = game:GetService("Stats")

local VersionTag = Window:Tag({
    Title = string.format("v%d | Ping: 0 | FPS: 0", version),
    Icon = "solar:server-bold",
    Color = Color3.fromRGB(255, 105, 180), -- Pink color
    Border = true,
})

local frames = 0
local last = os.clock()

RunService.RenderStepped:Connect(function()
    frames = frames + 1
    local now = os.clock()
    if now - last >= 1 then
        fps = frames
        frames = 0
        last = now

        -- Get ping
        pcall(function()
            local item = Stats.Network.ServerStatsItem:FindFirstChild("Data Ping")
            if item then
                ping = math.floor(item:GetValue())
            end
        end)

        -- Update tag
        VersionTag:SetTitle(string.format("v%d | Ping: %d | FPS: %d", version, ping, fps))
    end
end)

local MiscTab = Window:Tab({
    Title = "Settings",
    Icon = "settings",
    Locked = false,
})




-- Anti-AFK (Always Enabled - Prevents 20 min AFK kick)
local vu = game:GetService("VirtualUser")
player.Idled:Connect(function()
    vu:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
    task.wait(1)
    vu:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
end)

-- Auto Reconnect (Always Enabled)
pcall(function()
    game.CoreGui.RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
        if child.Name == 'ErrorPrompt' and child:FindFirstChild('MessageArea') and child.MessageArea:FindFirstChild("ErrorFrame") then
            game:GetService("TeleportService"):Teleport(game.PlaceId, player)
        end
    end)
end)

local MiscSettings = MiscTab:Section({
    Title = "Game Settings",
    Opened = true,
})

-- Anti-AFK (Always On)
MiscSettings:Button({
    Title = "Anti-AFK (Always On)",
    Desc = "Prevents AFK kick - Always enabled",
    Callback = function()
        WindUI:Notify({ Title = "Info", Content = "Anti-AFK is always enabled", Icon = "info", Duration = 2 })
    end
})

MiscSettings:Space()

-- Auto Reconnect (Always On)
MiscSettings:Button({
    Title = "Auto Reconnect (Always On)",
    Desc = "Auto rejoin on disconnect - Always enabled",
    Callback = function()
        WindUI:Notify({ Title = "Info", Content = "Auto Reconnect is always enabled", Icon = "info", Duration = 2 })
    end
})

MiscTab:Space()

MiscTab:Section({
    Title = "Server Actions",
    Opened = true,
})

local ServerGroup = MiscTab:Group()

ServerGroup:Button({
    Title = "Server Hop",
    Icon = "solar:refresh-bold",
    Callback = function()
        Window:ServerHop()
    end


})

ServerGroup:Space()

ServerGroup:Button({
    Title = "Rejoin",
    Icon = "solar:restart-bold",
    Callback = function()
        game:GetService("TeleportService"):Teleport(game.PlaceId, player)
    end
})

-- ================= MAIN TAB (Shop) =================
local MainTab = Window:Tab({
    Title = "Main Tab",
    Icon = "shopping-cart",
    Locked = false,
})

local ShopSection = MainTab:Section({ Title = "Shop Section", Opened = true })

-- State
local selectedGearItem = {}
local selectedSeedItem = {}
local selectedFruitItem = {}
local selectedFruitRarities = {}
local selectedSeedPackItem = {}
local autoBuyGear = false
local autoBuySeed = false
local autoSellFruit = false
local autoSellRarity = false
local autoSellAll = false
local autoOpenSeedPack = false
local autoShovel = false
local autoWater = false
local autoSprinkler = false
local shopCheckInterval = 0.5 -- check stock/price text every 0.5s
local fruitSellInterval = 1 -- seconds between fruit sell attempts
local fruitSellAmount = 1
local raritySellAmount = 1
local seedPackOpenInterval = 1
local scriptRunning = true
local autoSellProcessing = false
local shopBuyProcessing = false
local gearBuyLoopRunning = false
local seedBuyLoopRunning = false
local harvestStallCount = 0
local harvestStallThreshold = 3
local lastAutoSellAllAt = 0
local autoSellAllCooldown = 2

-- fast harvest state variables
local AutoHarvestConnection = nil
local FastHarvestEnabled = false

-- auto-plant/auto-harvest state will come from snippet logic
local autoPlant = false
local autoHarvest = false
local plantInterval = 0.3 -- used by snippet if needed
local harvestBatchSize = 5 -- number of times to fire each harvest prompt
local Seeds = {
    "Carrot","Tomato","Potato","Wheat","Pumpkin","Corn","Strawberry","Blueberry","Onion","Garlic","Cabbage","Banana","Apple","Plum","Cherry","Mushroom","Rose",
    "Dandelion","Bellpepper","Birch","Orange","Olive","Sunpetal","Goldenberry","Amberpine","Emberwood","Dawnblossom"
}
local selectedSeeds = {}
local selectedPlants = {}
local selectedRipenessStages = {}
local selectedFruitVariants = {}
local selectedFruitMutations = {}
local selectedShovelFruits = {}
local selectedShovelPlants = {}
local selectedWaterPlants = {}
local selectedSprinklerPlants = {}
local selectedSprinklerGear = {}
local ConfigManager = Window.ConfigManager
local configElements = {}
local selectedConfigFile = nil
local configInputName = ""
local autoLoadConfigFile = nil
local autoLoadMetaPath = "WindUI/XuanHub/config/autoload_config.json"
local PlantRemote = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("PlantSeed")
local SellRemote = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("SellItems")
local SpinRemote = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestSpin")
local RemovePlantRemote = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RemovePlant")
local UseGearRemote = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("UseGear")
local PurchaseShopItemRemote = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("PurchaseShopItem")
local PlantsModels = ReplicatedStorage:FindFirstChild("Plants") and ReplicatedStorage.Plants:FindFirstChild("Models")

local SELL_POINT = workspace:WaitForChild("MapPhysical"):WaitForChild("CashRegister"):WaitForChild("Part")
local ShopsFolder = workspace:WaitForChild("MapPhysical"):WaitForChild("Shops")

local function hasSelection(tbl)
    if type(tbl) ~= "table" then
        return false
    end
    for _, v in pairs(tbl) do
        if v then
            return true
        end
    end
    return false
end

local function withAllOption(values)
    local out = {"All"}
    if type(values) == "table" then
        for _, v in ipairs(values) do
            table.insert(out, v)
        end
    end
    return out
end

local function normalizeMultiSelection(option, allValues)
    local selected = {}
    if type(option) ~= "table" then
        return selected
    end

    local includeAll = false
    for _, value in ipairs(option) do
        local name = type(value) == "table" and value.Title or value
        if type(name) == "string" then
            if name == "All" then
                includeAll = true
            else
                table.insert(selected, name)
            end
        end
    end

    if includeAll then
        selected = {}
        if type(allValues) == "table" then
            for _, v in ipairs(allValues) do
                table.insert(selected, v)
            end
        end
    end

    return selected
end

local function toSelectionSet(option, allValues)
    local selected = {}
    if type(option) ~= "table" then
        return selected
    end

    local includeAll = false
    for key, value in pairs(option) do
        if type(key) == "number" then
            local name = type(value) == "table" and value.Title or value
            if type(name) == "string" then
                if name == "All" then
                    includeAll = true
                else
                    selected[name] = true
                end
            end
        elseif type(key) == "string" and value and key ~= "All" then
            selected[key] = true
        end
    end

    if includeAll and type(allValues) == "table" then
        selected = {}
        for _, v in ipairs(allValues) do
            selected[v] = true
        end
    end

    return selected
end

local function normalizeSingleSelection(option)
    if type(option) == "table" then
        return option.Title or option.Value or option[1]
    end
    if type(option) == "string" then
        return option
    end
    return nil
end

local function trackConfigElement(name, element)
    if type(name) ~= "string" or name == "" or not element then
        return
    end
    configElements[name] = element
end

local function registerConfigElements(configObj)
    if not configObj then
        return
    end
    for key, element in pairs(configElements) do
        pcall(function()
            configObj:Register(key, element)
        end)
    end
end

local function sanitizeConfigName(name)
    local clean = tostring(name or ""):gsub("^%s+", ""):gsub("%s+$", "")
    clean = clean:gsub("%.json$", "")
    clean = clean:gsub("[\\/:*?\"<>|]", "_")
    return clean
end

local function saveAutoLoadConfigName(configName)
    if not writefile or not HttpService then
        return false
    end
    local payload = HttpService:JSONEncode({
        config = configName
    })
    pcall(function()
        if makefolder and not isfolder("WindUI") then
            makefolder("WindUI")
        end
        if makefolder and not isfolder("WindUI/XuanHub") then
            makefolder("WindUI/XuanHub")
        end
        if makefolder and not isfolder("WindUI/XuanHub/config") then
            makefolder("WindUI/XuanHub/config")
        end
    end)
    local ok = pcall(function()
        writefile(autoLoadMetaPath, payload)
    end)
    return ok
end

local function clearAutoLoadConfigName()
    autoLoadConfigFile = nil
    if delfile and isfile and isfile(autoLoadMetaPath) then
        pcall(function()
            delfile(autoLoadMetaPath)
        end)
    end
end

local function loadAutoLoadConfigName()
    if not readfile or not isfile or not HttpService or not isfile(autoLoadMetaPath) then
        return nil
    end
    local ok, raw = pcall(function()
        return readfile(autoLoadMetaPath)
    end)
    if not ok or type(raw) ~= "string" or raw == "" then
        return nil
    end
    local decodedOk, data = pcall(function()
        return HttpService:JSONDecode(raw)
    end)
    if not decodedOk or type(data) ~= "table" then
        return nil
    end
    local cfg = sanitizeConfigName(data.config)
    if cfg == "" then
        return nil
    end
    return cfg
end

local function getConfigFileList()
    local files = {}
    local ok, list = pcall(function()
        return ConfigManager:AllConfigs()
    end)
    if ok and type(list) == "table" then
        for _, name in ipairs(list) do
            if type(name) == "string" and name ~= "" then
                table.insert(files, name)
            end
        end
    end
    table.sort(files)
    return files
end

autoLoadConfigFile = loadAutoLoadConfigName()

MiscTab:Space()

local ConfigSection = MiscTab:Section({
    Title = "Config Manager (JSON)",
    Opened = true,
})

local ConfigFileDropdown
local function hasConfigName(files, wantedName)
    local target = sanitizeConfigName(wantedName)
    if target == "" then
        return false
    end
    for _, name in ipairs(files) do
        if sanitizeConfigName(name) == target then
            return true
        end
    end
    return false
end

local function refreshConfigDropdown()
    local files = getConfigFileList()
    if ConfigFileDropdown then
        ConfigFileDropdown:Refresh(files)
    end
    if selectedConfigFile and not hasConfigName(files, selectedConfigFile) then
        selectedConfigFile = nil
    end
    if autoLoadConfigFile and not hasConfigName(files, autoLoadConfigFile) then
        clearAutoLoadConfigName()
    end
end

ConfigSection:Input({
    Title = "Config File Name",
    Desc = "Name used when saving JSON config",
    Value = "",
    Placeholder = "e.g. farm_setup_1",
    Type = "Input",
    Callback = function(value)
        configInputName = sanitizeConfigName(value)
    end,
})

ConfigSection:Button({
    Title = "Save Config",
    Desc = "Save current registered UI values",
    Callback = function()
        local cfgName = sanitizeConfigName(configInputName)
        if cfgName == "" then
            WindUI:Notify({ Title = "Config", Content = "Input a config file name first", Icon = "alert-triangle", Duration = 2 })
            return
        end
        local configObj = ConfigManager:CreateConfig(cfgName)
        registerConfigElements(configObj)
        local ok, err = pcall(function()
            configObj:Save()
        end)
        if ok then
            selectedConfigFile = cfgName
            refreshConfigDropdown()
            WindUI:Notify({ Title = "Config", Content = "Saved: " .. cfgName .. ".json", Icon = "check", Duration = 2 })
        else
            WindUI:Notify({ Title = "Config", Content = "Save failed: " .. tostring(err), Icon = "alert-triangle", Duration = 2 })
        end
    end
})

ConfigFileDropdown = ConfigSection:Dropdown({
    Title = "Select Config File",
    Desc = "Pick a saved file to load or auto-load",
    Values = getConfigFileList(),
    Value = autoLoadConfigFile or "",
    Multi = false,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        local picked = normalizeSingleSelection(option)
        if type(picked) == "string" and picked ~= "" then
            selectedConfigFile = picked
        else
            selectedConfigFile = nil
        end
    end,
})

ConfigSection:Button({
    Title = "Load Selected Config",
    Desc = "Load selected JSON config now",
    Callback = function()
        local cfgName = sanitizeConfigName(selectedConfigFile)
        if cfgName == "" then
            WindUI:Notify({ Title = "Config", Content = "Select config file first", Icon = "alert-triangle", Duration = 2 })
            return
        end
        local configObj = ConfigManager:CreateConfig(cfgName)
        registerConfigElements(configObj)
        local ok, err = pcall(function()
            configObj:Load()
        end)
        if ok then
            WindUI:Notify({ Title = "Config", Content = "Loaded: " .. cfgName .. ".json", Icon = "check", Duration = 2 })
        else
            WindUI:Notify({ Title = "Config", Content = "Load failed: " .. tostring(err), Icon = "alert-triangle", Duration = 2 })
        end
    end
})

ConfigSection:Toggle({
    Title = "Auto Load Selected Config",
    Desc = "Auto-load this file after script executes",
    Value = autoLoadConfigFile ~= nil,
    Callback = function(state)
        if not state then
            clearAutoLoadConfigName()
            WindUI:Notify({ Title = "Config", Content = "Auto-load disabled", Icon = "info", Duration = 2 })
            return
        end
        local cfgName = sanitizeConfigName(selectedConfigFile)
        if cfgName == "" then
            WindUI:Notify({ Title = "Config", Content = "Select config file first", Icon = "alert-triangle", Duration = 2 })
            return
        end
        autoLoadConfigFile = cfgName
        if saveAutoLoadConfigName(cfgName) then
            WindUI:Notify({ Title = "Config", Content = "Auto-load set: " .. cfgName .. ".json", Icon = "check", Duration = 2 })
        else
            WindUI:Notify({ Title = "Config", Content = "Auto-load save failed (executor fs unavailable)", Icon = "alert-triangle", Duration = 2 })
        end
    end,
})

ConfigSection:Button({
    Title = "Refresh Configs (Clear Auto Load)",
    Desc = "Refresh list and reset auto-load selection",
    Callback = function()
        selectedConfigFile = nil
        clearAutoLoadConfigName()
        refreshConfigDropdown()
        WindUI:Notify({ Title = "Config", Content = "Config list refreshed and auto-load cleared", Icon = "info", Duration = 2 })
    end
})

MiscTab:Space()

local function getSeedBaseNameFromTool(tool)
    if not tool or not tool:IsA("Tool") then
        return nil
    end

    local baseName = tool:GetAttribute("BaseName")
    if type(baseName) == "string" then
        return baseName
    end

    return nil
end

local function findAndEquipSeedTool(seedBaseName)
    local char = player.Character
    local backpack = player:FindFirstChild("Backpack")
    if not char or not backpack then
        return false, nil
    end

    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        return false, nil
    end

    local wanted = tostring(seedBaseName):lower()

    local function getPlantType(tool)
        local plantType = tool:GetAttribute("PlantType")
        if type(plantType) == "string" and plantType ~= "" then
            return plantType
        end

        local baseName = getSeedBaseNameFromTool(tool)
        if type(baseName) == "string" then
            return baseName:gsub("%s*Seed$", "")
        end
        return nil
    end

    for _, tool in ipairs(char:GetChildren()) do
        if tool:IsA("Tool") then
            local baseName = getSeedBaseNameFromTool(tool)
            if type(baseName) == "string" and baseName:lower() == wanted then
                return true, getPlantType(tool)
            end
        end
    end

    for _, tool in ipairs(backpack:GetChildren()) do
        if tool:IsA("Tool") then
            local baseName = getSeedBaseNameFromTool(tool)
            if type(baseName) == "string" and baseName:lower() == wanted then
                humanoid:EquipTool(tool)
                task.wait(0.05)
                return true, getPlantType(tool)
            end
        end
    end

    return false, nil
end

local function findAndEquipSeedPackTool(seedPackDisplayName)
    local char = player.Character
    local backpack = player:FindFirstChild("Backpack")
    if not char or not backpack then
        return false
    end

    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        return false
    end

    local wanted = tostring(seedPackDisplayName):lower()

    for _, tool in ipairs(char:GetChildren()) do
        if tool:IsA("Tool") then
            local baseName = tool:GetAttribute("BaseName")
            if type(baseName) == "string" and baseName:lower() == wanted then
                return true
            end
        end
    end

    for _, tool in ipairs(backpack:GetChildren()) do
        if tool:IsA("Tool") then
            local baseName = tool:GetAttribute("BaseName")
            if type(baseName) == "string" and baseName:lower() == wanted then
                humanoid:EquipTool(tool)
                task.wait(0.05)
                return true
            end
        end
    end

    return false
end

local function findAndEquipShovelTool()
    local char = player.Character
    local backpack = player:FindFirstChild("Backpack")
    if not char or not backpack then
        return false
    end

    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        return false
    end

    local function isShovel(tool)
        if not tool or not tool:IsA("Tool") then
            return false
        end
        local baseName = tool:GetAttribute("BaseName")
        if type(baseName) == "string" and baseName:lower():find("shovel", 1, true) then
            return true
        end
        return type(tool.Name) == "string" and tool.Name:lower():find("shovel", 1, true) ~= nil
    end

    for _, tool in ipairs(char:GetChildren()) do
        if isShovel(tool) then
            return true
        end
    end

    for _, tool in ipairs(backpack:GetChildren()) do
        if isShovel(tool) then
            humanoid:EquipTool(tool)
            task.wait(0.05)
            return true
        end
    end

    return false
end

local function findAndEquipWateringCanTool()
    local char = player.Character
    local backpack = player:FindFirstChild("Backpack")
    if not char or not backpack then
        return false
    end

    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        return false
    end

    local function isWateringCan(tool)
        if not tool or not tool:IsA("Tool") then
            return false
        end
        local baseName = tool:GetAttribute("BaseName")
        if type(baseName) == "string" and baseName:lower() == "watering can" then
            return true
        end
        return type(tool.Name) == "string" and tool.Name:lower() == "watering can"
    end

    for _, tool in ipairs(char:GetChildren()) do
        if isWateringCan(tool) then
            return true
        end
    end

    for _, tool in ipairs(backpack:GetChildren()) do
        if isWateringCan(tool) then
            humanoid:EquipTool(tool)
            task.wait(0.05)
            return true
        end
    end

    return false
end

-- previous helper for finding seed tool removed; using direct PlantSeed remote instead
-- Helpers: fetch shop items heuristically
local function fetchShopItems(shopId)
    -- Return exact, hardcoded lists for GearShop and SeedShop to match server item names
    if shopId == "GearShop" then
        return { "Watering Can", "Basic Sprinkler", "Harvest Bell", "Turbo Sprinkler", "Favorite Tool", "Super Sprinkler" }
    elseif shopId == "SeedShop" then
        return {
            "Carrot Seed",
            "Corn Seed",
            "Onion Seed",
            "Strawberry Seed",
            "Mushroom Seed",
            "Beetroot Seed",
            "Tomato Seed",
            "Apple Seed",
            "Rose Seed",
            "Wheat Seed",
            "Banana Seed",
            "Plum Seed",
            "Potato Seed",
            "Cabbage Seed",
            "Cherry Seed",
        }
    end
    return {}
end

-- gather list of fruit harvest origins present in backpack/equipped tools
local function fetchFruitItems()
    local fruits = {}
    local seen = {}
    local bp = player and player:FindFirstChild("Backpack")
    if bp then
        for _, tool in ipairs(bp:GetChildren()) do
            if tool:IsA("Tool") then
                local hf = tool:GetAttribute("HarvestedFrom")
                if hf and not seen[hf] then
                    seen[hf] = true
                    table.insert(fruits, hf)
                end
            end
        end
    end
    local char = player and player.Character
    if char then
        for _, tool in ipairs(char:GetChildren()) do
            if tool:IsA("Tool") then
                local hf = tool:GetAttribute("HarvestedFrom")
                if hf and not seen[hf] then
                    seen[hf] = true
                    table.insert(fruits, hf)
                end
            end
        end
    end
    table.sort(fruits)
    return fruits
end

local function countHarvestedFruitTools()
    local count = 0
    local bp = player and player:FindFirstChild("Backpack")
    if bp then
        for _, tool in ipairs(bp:GetChildren()) do
            if tool:IsA("Tool") and tool:GetAttribute("HarvestedFrom") then
                count = count + 1
            end
        end
    end
    local char = player and player.Character
    if char then
        for _, tool in ipairs(char:GetChildren()) do
            if tool:IsA("Tool") and tool:GetAttribute("HarvestedFrom") then
                count = count + 1
            end
        end
    end
    return count
end

local function countFruitToolsByType(fruitName)
    local count = 0
    local target = tostring(fruitName):lower()
    local bp = player and player:FindFirstChild("Backpack")
    if bp then
        for _, tool in ipairs(bp:GetChildren()) do
            if tool:IsA("Tool") then
                local hf = tool:GetAttribute("HarvestedFrom")
                if hf and tostring(hf):lower() == target then
                    count = count + 1
                end
            end
        end
    end

    local char = player and player.Character
    if char then
        for _, tool in ipairs(char:GetChildren()) do
            if tool:IsA("Tool") then
                local hf = tool:GetAttribute("HarvestedFrom")
                if hf and tostring(hf):lower() == target then
                    count = count + 1
                end
            end
        end
    end
    return count
end

local function parseNumberFromText(text)
    if type(text) ~= "string" then
        return 0
    end
    local clean = text:gsub(",", ""):lower()
    local numStr, suffix = clean:match("(%d+%.?%d*)%s*([kmb])")
    local value
    if numStr then
        value = tonumber(numStr) or 0
        if suffix == "k" then
            value = value * 1e3
        elseif suffix == "m" then
            value = value * 1e6
        elseif suffix == "b" then
            value = value * 1e9
        end
        return math.floor(value)
    end

    local plain = clean:match("(%d+%.?%d*)")
    return math.floor(tonumber(plain) or 0)
end

local function parseStockFromText(text)
    if type(text) ~= "string" then
        return 0
    end

    local lowered = text:lower()
    if lowered:find("no stock", 1, true) then
        return 0
    end

    -- Common stock format like "10x" or "10 x"
    local xCount = lowered:match("(%d+)%s*x")
    if xCount then
        return tonumber(xCount) or 0
    end

    return parseNumberFromText(text)
end


local function getCurrentMoney()
    local playerGui = player:FindFirstChild("PlayerGui")
    if not playerGui then
        return 0
    end

    local currencyAmount = playerGui:FindFirstChild("ShillingsCurrency")
    currencyAmount = currencyAmount and currencyAmount:FindFirstChild("CurrencyAmount")
    if not currencyAmount then
        return 0
    end

    return parseNumberFromText(currencyAmount.Text)
end

local function normalizeShopName(text)
    if type(text) ~= "string" then
        return ""
    end
    return text:lower():gsub("[^%w]", "")
end

local function getShopItemPanel(shopUiName, itemNameOrCandidates)
    local playerGui = player:FindFirstChild("PlayerGui")
    if not playerGui then
        return nil
    end

    local shopGui = playerGui:FindFirstChild(shopUiName)
    local frame = shopGui and shopGui:FindFirstChild("Frame")
    local scrollingFrame = frame and frame:FindFirstChild("ScrollingFrame")
    if not scrollingFrame then
        return nil
    end

    local candidates = {}
    if type(itemNameOrCandidates) == "table" then
        for _, name in ipairs(itemNameOrCandidates) do
            if type(name) == "string" and name ~= "" then
                table.insert(candidates, name)
            end
        end
    elseif type(itemNameOrCandidates) == "string" and itemNameOrCandidates ~= "" then
        table.insert(candidates, itemNameOrCandidates)
    end
    if #candidates == 0 then
        return nil
    end

    -- exact lookup first
    for _, candidate in ipairs(candidates) do
        local exact = scrollingFrame:FindFirstChild(candidate)
        if exact then
            return exact
        end
    end

    -- normalized fallback (handles spaces/case differences)
    local wanted = {}
    for _, candidate in ipairs(candidates) do
        wanted[normalizeShopName(candidate)] = true
    end

    for _, child in ipairs(scrollingFrame:GetChildren()) do
        if wanted[normalizeShopName(child.Name)] then
            return child
        end
    end

    return nil
end

local function getShopItemStockAndPrice(shopUiName, itemNameOrCandidates)
    local panel = getShopItemPanel(shopUiName, itemNameOrCandidates)
    if not panel then
        return 0, 0
    end

    local mainInfo = panel:FindFirstChild("MainInfo")
    if not mainInfo then
        return 0, 0
    end

    local stockText = mainInfo:FindFirstChild("StockText")
    local priceText = mainInfo:FindFirstChild("PriceText")
    local stockValue = stockText and stockText.Text or ""
    local priceValue = priceText and priceText.Text or ""

    local stock = parseStockFromText(stockValue)
    local price = parseNumberFromText(priceValue)
    return stock, price
end

local function getShopTeleportPart(shopName, indexHint)
    local shopModel = ShopsFolder:FindFirstChild(shopName)
    if not shopModel then
        return nil
    end

    local children = shopModel:GetChildren()
    local hinted = children[indexHint]
    if hinted and hinted:IsA("BasePart") then
        return hinted
    end

    for _, child in ipairs(children) do
        if child:IsA("BasePart") then
            return child
        end
    end
    return nil
end

local function performShopAutoBuy(shopId, shopUiName, shopWorldName, teleportIndex, selectedItems, toDisplayName)
    if not selectedItems or #selectedItems == 0 then
        return
    end
    if shopBuyProcessing then
        return
    end

    local character = player.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        return
    end

    local function buildCandidates(item)
        local displayName = tostring(toDisplayName(item) or "")
        local itemName = tostring(item)
        local itemBase = itemName:gsub("%s*Seed$", "")
        return {
            displayName,
            itemName,
            itemBase,
            displayName:gsub("%s+", ""),
            itemName:gsub("%s+", ""),
            itemBase:gsub("%s+", ""),
        }
    end

    local function hasAnyAffordableItem()
        local money = getCurrentMoney()
        if money <= 0 then
            return false
        end
        for _, item in ipairs(selectedItems) do
            local stock, price = getShopItemStockAndPrice(shopUiName, buildCandidates(item))
            if stock > 0 and price > 0 and money >= price then
                return true
            end
        end
        return false
    end

    if not hasAnyAffordableItem() then
        return
    end

    shopBuyProcessing = true
    for _, item in ipairs(selectedItems) do
        -- pre-warm UI reads (kept intentionally light)
        getShopItemStockAndPrice(shopUiName, buildCandidates(item))
    end

    local ok = pcall(function()
        -- Re-check immediately before teleport to avoid stale UI/money reads.
        if not hasAnyAffordableItem() then
            return
        end

        local shopPart = getShopTeleportPart(shopWorldName, teleportIndex)
        if not shopPart then
            return
        end

        local oldCFrame = hrp.CFrame
        hrp.CFrame = shopPart.CFrame
        task.wait(1.2)

        -- One teleport session: keep buying until no selected item is affordable or all are out of stock.
        local passGuard = 0
        while passGuard < 100 do
            passGuard = passGuard + 1
            local boughtInPass = false
            local money = getCurrentMoney()
            if money <= 0 then
                break
            end

            local orderedItems = {}
            for _, item in ipairs(selectedItems) do
                local stock, price = getShopItemStockAndPrice(shopUiName, buildCandidates(item))
                if stock > 0 and price > 0 then
                    table.insert(orderedItems, {
                        item = item,
                        stock = stock,
                        price = price,
                    })
                end
            end

            table.sort(orderedItems, function(a, b)
                return a.price < b.price
            end)

            for _, entry in ipairs(orderedItems) do
                local affordable = math.floor(money / entry.price)
                if affordable > 0 then
                    local quantity = math.min(entry.stock, affordable)
                    for _ = 1, quantity do
                        pcall(function()
                            PurchaseShopItemRemote:InvokeServer(shopId, entry.item)
                        end)
                        task.wait(0.08)
                    end
                    boughtInPass = true
                    money = getCurrentMoney()
                    if money <= 0 then
                        break
                    end
                end
            end

            if not boughtInPass then
                break
            end
            task.wait(0.1)
        end

        task.wait(0.3)
        if hrp then
            hrp.CFrame = oldCFrame
        end
    end)

    shopBuyProcessing = false
    if not ok then
        return
    end
end

-- forward declaration so sell helpers use the correct local function
local equipFruitTool

local function performAutoSellAll()
    if autoSellProcessing then
        return false
    end
    local expectedNotificationText = "Your inventory is full! Sell or remove items to make space."
    local playerGui = player and player:FindFirstChild("PlayerGui")
    local notificationGui = playerGui and playerGui:FindFirstChild("Notification")
    local notificationFrame = notificationGui and notificationGui:FindFirstChild("Frame")
    local function readTextFromGuiObject(guiObj)
        if not guiObj then
            return nil
        end
        if guiObj:IsA("TextLabel") or guiObj:IsA("TextButton") or guiObj:IsA("TextBox") then
            return tostring(guiObj.Text or "")
        end
        local directText = guiObj:FindFirstChild("Text")
        if directText and (directText:IsA("TextLabel") or directText:IsA("TextButton") or directText:IsA("TextBox")) then
            return tostring(directText.Text or "")
        end
        for _, d in ipairs(guiObj:GetDescendants()) do
            if d.Name == "Text" and (d:IsA("TextLabel") or d:IsA("TextButton") or d:IsA("TextBox")) then
                return tostring(d.Text or "")
            end
        end
        return nil
    end

    local foundInventoryFullNotification = false
    if notificationFrame then
        for _, inst in ipairs(notificationFrame:GetDescendants()) do
            if inst.Name == "CONTENT" then
                local contentText = readTextFromGuiObject(inst)
                if contentText == expectedNotificationText then
                    foundInventoryFullNotification = true
                    break
                end
            end
        end
    end
    if not foundInventoryFullNotification then
        return false
    end

    autoSellProcessing = true

    local character = player.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        autoSellProcessing = false
        return false
    end

    local oldCFrame = hrp.CFrame
    hrp.CFrame = SELL_POINT.CFrame
    task.wait(1.5)

    pcall(function()
        SellRemote:InvokeServer("SellAll")
    end)

    task.wait(1)
    if hrp and hrp.Parent then
        hrp.CFrame = oldCFrame
    end

    autoSellProcessing = false
    return true
end

local function performAutoSellSingleBatch(sellAmountByFruit)
    if autoSellProcessing then
        return
    end
    if type(sellAmountByFruit) ~= "table" then
        return
    end

    local fruitsToSell = {}
    for fruit, sellAmount in pairs(sellAmountByFruit) do
        local wantedCount = math.max(1, tonumber(sellAmount) or 1)
        local availableCount = countFruitToolsByType(fruit)
        if availableCount > 0 then
            fruitsToSell[fruit] = math.min(wantedCount, availableCount)
        end
    end

    if next(fruitsToSell) == nil then
        return
    end

    autoSellProcessing = true
    local character = player.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        autoSellProcessing = false
        return
    end

    local oldCFrame = hrp.CFrame
    hrp.CFrame = SELL_POINT.CFrame
    task.wait(1.5)

    for fruit, sellCount in pairs(fruitsToSell) do
        for _ = 1, sellCount do
            if not equipFruitTool(fruit) then
                break
            end
            pcall(function()
                SellRemote:InvokeServer("SellSingle")
            end)
            task.wait(0.1)
        end
    end

    task.wait(0.5)
    if hrp then
        hrp.CFrame = oldCFrame
    end
    autoSellProcessing = false
end

-- attempt to equip a tool corresponding to given fruit name
equipFruitTool = function(fruitName)
    local bp = player and player:FindFirstChild("Backpack")
    local char = player and player.Character
    if not bp or not char then return false end
    local humanoid = char:FindFirstChild("Humanoid")
    if not humanoid then return false end
    local wanted = tostring(fruitName):lower()

    for _, tool in ipairs(bp:GetChildren()) do
        if tool:IsA("Tool") then
            local hf = tool:GetAttribute("HarvestedFrom")
            if hf and tostring(hf):lower() == wanted then
                humanoid:EquipTool(tool)
                task.wait(0.06)
                if tool.Parent == char then
                    return true
                end
            end
        end
    end
    for _, tool in ipairs(char:GetChildren()) do
        if tool:IsA("Tool") then
            local hf = tool:GetAttribute("HarvestedFrom")
            if hf and tostring(hf):lower() == wanted then
                return true
            end
        end
    end

    -- fallback if some fruits miss HarvestedFrom and only have BaseName/Name
    for _, tool in ipairs(bp:GetChildren()) do
        if tool:IsA("Tool") then
            local baseName = tool:GetAttribute("BaseName")
            if (type(baseName) == "string" and baseName:lower() == wanted) or (type(tool.Name) == "string" and tool.Name:lower() == wanted) then
                humanoid:EquipTool(tool)
                task.wait(0.06)
                if tool.Parent == char then
                    return true
                end
            end
        end
    end
    for _, tool in ipairs(char:GetChildren()) do
        if tool:IsA("Tool") then
            local baseName = tool:GetAttribute("BaseName")
            if (type(baseName) == "string" and baseName:lower() == wanted) or (type(tool.Name) == "string" and tool.Name:lower() == wanted) then
                return true
            end
        end
    end

    return false
end

-- find a seed tool in backpack/character whose BaseName attribute matches seedBase
-- findSeedTool removed (auto-plant disabled)

-- Attempt to trigger a harvest prompt safely using multiple fallbacks
-- fireHarvestPrompt removed (auto-harvest disabled)

local gearList = {}
local seedList = {}
local fruitList = {
    "Carrot","Corn","Onion","Strawberry","Mushroom","Beetroot","Tomato","Apple","Rose","Wheat","Banana","Plum","Potato","Cabbage","Cherry",
    "Dandelion","Bellpepper","Birch","Orange","Olive","Sunpetal","Goldenberry","Amberpine","Emberwood","Dawnblossom"
}
local plantSeedList = {
    "Carrot Seed","Corn Seed","Onion Seed","Strawberry Seed","Mushroom Seed","Beetroot Seed","Tomato Seed","Apple Seed","Rose Seed","Wheat Seed","Banana Seed","Plum Seed","Potato Seed","Cabbage Seed","Cherry Seed",
    "Dandelion Seed","Bellpepper Seed","Birch Seed","Orange Seed","Olive Seed","Sunpetal Seed","Goldenberry Seed","Amberpine Seed","Emberwood Seed","Dawnblossom Seed"
}
local seedsByRarity = {
    Common = {"Carrot", "Corn"},
    Uncommon = {"Onion", "Strawberry", "Mushroom"},
    Rare = {"Beetroot", "Tomato", "Apple", "Rose"},
    Epic = {"Wheat", "Banana", "Plum", "Potato"},
    Legendary = {"Cabbage Seed", "Cherry"},
}
local rarityList = {"Common", "Uncommon", "Rare", "Epic", "Legendary"}
local ripenessStageList = {"Lush", "Ripened", "Unripe"}
local fruitVariantList = {"Silver", "Gold", "Normal"}
local fruitMutationList = {"Sandy","Soaked","Shocked","Nova","Starstruck","Snowy","Foggy","Meteoric","Tidal","Flooded","Chilled","Frostbit","Muddy","Mossy"}
local seedPackList = {
    "Gardener Seed Pack",
    "Premium Gardener Seed Pack",
    "Dawn Seed Pack",
    "Premium Dawn Seed Pack",
}

-- Populate lists (keep them local tables to avoid accidental global usage)
gearList = fetchShopItems("GearShop")
seedList = fetchShopItems("SeedShop")
local gearDropdownValues = withAllOption(gearList)
local seedDropdownValues = withAllOption(seedList)
local fruitDropdownValues = withAllOption(fruitList)
local plantSeedDropdownValues = withAllOption(plantSeedList)
local rarityDropdownValues = withAllOption(rarityList)
local ripenessDropdownValues = withAllOption(ripenessStageList)
local fruitVariantDropdownValues = withAllOption(fruitVariantList)
local fruitMutationDropdownValues = withAllOption(fruitMutationList)
local seedPackDropdownValues = withAllOption(seedPackList)
local sprinklerGearList = {}
for _, gearName in ipairs(gearList) do
    if type(gearName) == "string" and gearName:lower():find("sprinkler", 1, true) then
        table.insert(sprinklerGearList, gearName)
    end
end
if #sprinklerGearList == 0 then
    sprinklerGearList = {"Basic Sprinkler", "Turbo Sprinkler", "Super Sprinkler"}
end
selectedSprinklerGear = {sprinklerGearList[1]}

local function normalizeFruitName(name)
    if type(name) ~= "string" then
        return nil
    end
    return (name:gsub("%s*Seed$", ""))
end

local function getRarityFruitList(raritySet)
    local out = {}
    local seen = {}
    if type(raritySet) ~= "table" then
        return out
    end

    for rarity, enabled in pairs(raritySet) do
        if enabled and type(seedsByRarity[rarity]) == "table" then
            for _, name in ipairs(seedsByRarity[rarity]) do
                local fruit = normalizeFruitName(name)
                if fruit and not seen[fruit] then
                    seen[fruit] = true
                    table.insert(out, fruit)
                end
            end
        end
    end
    return out
end

local function normalizeRipenessStageName(stageName)
    local s = tostring(stageName or ""):lower()
    if s == "" then
        return ""
    end
    if s == "ripened" or s == "ripe" or s == "repined" then
        return "ripe"
    end
    if s == "unripe" or s == "unripened" or s == "unriped" then
        return "unripe"
    end
    return s
end



-- Auto Harvest Function (supports optional ripeness + variant + mutation filters)
function autoHarvestPlants(selectedPlants, selectedStages, selectedVariants, selectedMutations)
    local clientPlants = workspace:FindFirstChild("ClientPlants")
    if not clientPlants then
        return
    end

    local plantsTable = (type(selectedPlants) == "table") and selectedPlants or {}
    local stagesTable = (type(selectedStages) == "table") and selectedStages or {}
    local variantsTable = (type(selectedVariants) == "table") and selectedVariants or {}
    local mutationsTable = (type(selectedMutations) == "table") and selectedMutations or {}
    local hasPlantFilter = hasSelection(plantsTable)
    local hasStageFilter = hasSelection(stagesTable)
    local hasVariantFilter = hasSelection(variantsTable)
    local hasMutationFilter = hasSelection(mutationsTable)
    local harvestAttempts = 0

    for _, plant in pairs(clientPlants:GetChildren()) do
        local base = plant.Name:gsub("%d","")
        local matchesPlant = (not hasPlantFilter) or plantsTable[base]
        local fruitFilterMatched = (not hasStageFilter and not hasVariantFilter and not hasMutationFilter)

        if not fruitFilterMatched then
            for _, obj in ipairs(plant:GetDescendants()) do
                if obj.Name and obj.Name:match("^Fruit%d+$") then
                    local stage = obj:GetAttribute("RipenessStage")
                    local variant = obj:GetAttribute("Variant")
                    local mutation = obj:GetAttribute("Mutation")

                    local stageOk = (not hasStageFilter)
                    if hasStageFilter then
                        local normalizedStage = normalizeRipenessStageName(stage)
                        if normalizedStage ~= "" then
                            for selectedStage, enabled in pairs(stagesTable) do
                                if enabled and normalizeRipenessStageName(selectedStage) == normalizedStage then
                                    stageOk = true
                                    break
                                end
                            end
                        end
                    end
                    local variantOk = not hasVariantFilter
                    if hasVariantFilter then
                        if type(variant) == "string" and variant ~= "" then
                            variantOk = variantsTable[variant] == true
                        else
                            -- "Normal" means fruit has no Variant attribute set
                            variantOk = variantsTable["Normal"] == true
                        end
                    end

                    local mutationOk = (not hasMutationFilter)
                    if hasMutationFilter and type(mutation) == "string" and mutation ~= "" then
                        mutationOk = mutationsTable[mutation] == true
                    elseif hasMutationFilter then
                        mutationOk = false
                    end

                    if stageOk and variantOk and mutationOk then
                        fruitFilterMatched = true
                        break
                    end
                end
            end
        end

if matchesPlant and fruitFilterMatched then
    for _, v in ipairs(plant:GetDescendants()) do
        if v:IsA("ProximityPrompt") and v.Name == "HarvestPrompt" and v.Enabled then
            harvestAttempts = harvestAttempts + 1
            v.HoldDuration = 0
            
            -- ðŸ”¥ ULTRA FAST BATCH HARVEST (3x faster)
            local batchSize = harvestBatchSize or 8  -- Configurable batch size
            local ultraFastMode = true  -- Toggle for max speed
            
            if ultraFastMode then
                -- METHOD 1: Pure fireproximityprompt spam (FASTEST)
                for i = 1, batchSize do
                    task.spawn(function()  -- Parallel spam for max speed
                        pcall(fireproximityprompt, v)
                    end)
                end
                
            else
                -- METHOD 2: Fallback InputHold (more compatible)
                for i = 1, batchSize do
                    pcall(function() v:InputHoldBegin() end)
                    task.wait(0.001)  -- Micro delay for stability
                    pcall(function() v:InputHoldEnd() end)
                    task.wait(0.001)
                end
            end
            
            -- Tiny cooldown to prevent server lag/desync
            task.wait(0.008)
            break  -- Only need to fire once per plant
        end
    end
        end
    end 
                

    return harvestAttempts
end

-- Shovel Function (fruit => uuid,1 | plant => uuid)
function autoShovelTargets(selectedFruitTypes, selectedPlantTypes)
    local clientPlants = workspace:FindFirstChild("ClientPlants")
    if not clientPlants then
        return
    end
    if not findAndEquipShovelTool() then
        return
    end

    local fruitTypes = (type(selectedFruitTypes) == "table") and selectedFruitTypes or {}
    local plantTypes = (type(selectedPlantTypes) == "table") and selectedPlantTypes or {}

    for _, plant in ipairs(clientPlants:GetChildren()) do
        local plantType = plant:GetAttribute("PlantType")
        if type(plantType) ~= "string" or plantType == "" then
            plantType = plant.Name:gsub("%d", "")
        end

        local uuid = plant:GetAttribute("Uuid")
        if type(uuid) ~= "string" or uuid == "" then
            uuid = plant:GetAttribute("UUID")
        end

        if type(uuid) == "string" and uuid ~= "" then
            if fruitTypes[plantType] then
                -- Always remove with amount=1; repeat a few times to clear all fruit stacks.
                for _ = 1, 8 do
                    pcall(function()
                        RemovePlantRemote:FireServer(uuid, 1)
                    end)
                    task.wait(0.03)
                end
            elseif plantTypes[plantType] then
                pcall(function()
                    RemovePlantRemote:FireServer(uuid)
                end)
            end
        end
    end
end

-- Auto Water Function (equip Watering Can, water selected PlantType one-by-one)
function autoWaterPlants(selectedPlantTypes)
    local clientPlants = workspace:FindFirstChild("ClientPlants")
    if not clientPlants then
        return
    end
    if not findAndEquipWateringCanTool() then
        return
    end

    local plantTypes = (type(selectedPlantTypes) == "table") and selectedPlantTypes or {}
    local targets = {}

    for _, plant in ipairs(clientPlants:GetChildren()) do
        local plantType = plant:GetAttribute("PlantType")
        if type(plantType) ~= "string" or plantType == "" then
            plantType = plant.Name:gsub("%d", "")
        end

        if plantTypes[plantType] then
            local pos
            if plant:IsA("Model") then
                pos = plant:GetPivot().Position
            elseif plant:IsA("BasePart") then
                pos = plant.Position
            end

            if pos then
                table.insert(targets, pos)
            end
        end
    end

    for _, pos in ipairs(targets) do
        pcall(function()
            local args = {
                "Watering Can",
                {
                    position = pos
                }
            }
            UseGearRemote:FireServer(unpack(args))
        end)
        task.wait(0.08)
    end
end

local function findAndEquipSprinklerTool(sprinklerName)
    local char = player.Character
    local backpack = player:FindFirstChild("Backpack")
    if not char or not backpack then
        return false
    end

    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        return false
    end

    local wanted = tostring(sprinklerName or ""):lower()
    if wanted == "" then
        return false
    end

    local function isWantedSprinkler(tool)
        if not tool or not tool:IsA("Tool") then
            return false
        end
        local baseName = tool:GetAttribute("BaseName")
        if type(baseName) == "string" and baseName:lower() == wanted then
            return true
        end
        return type(tool.Name) == "string" and tool.Name:lower() == wanted
    end

    for _, tool in ipairs(char:GetChildren()) do
        if isWantedSprinkler(tool) then
            return true
        end
    end

    for _, tool in ipairs(backpack:GetChildren()) do
        if isWantedSprinkler(tool) then
            humanoid:EquipTool(tool)
            task.wait(0.05)
            return true
        end
    end

    return false
end

function autoSprinklerPlants(selectedPlantTypes, sprinklerNames)
    local clientPlants = workspace:FindFirstChild("ClientPlants")
    if not clientPlants then
        return
    end
    local namesToUse = {}
    if type(sprinklerNames) == "table" then
        for _, n in ipairs(sprinklerNames) do
            if type(n) == "string" and n ~= "" then
                table.insert(namesToUse, n)
            end
        end
    elseif type(sprinklerNames) == "string" and sprinklerNames ~= "" then
        table.insert(namesToUse, sprinklerNames)
    end
    if #namesToUse == 0 then
        return
    end

    local plantTypes = (type(selectedPlantTypes) == "table") and selectedPlantTypes or {}
    local targets = {}

    for _, plant in ipairs(clientPlants:GetChildren()) do
        local plantType = plant:GetAttribute("PlantType")
        if type(plantType) ~= "string" or plantType == "" then
            plantType = plant.Name:gsub("%d", "")
        end

        if plantTypes[plantType] then
            local pos
            if plant:IsA("Model") then
                pos = plant:GetPivot().Position
            elseif plant:IsA("BasePart") then
                pos = plant.Position
            end

            if pos then
                table.insert(targets, pos)
            end
        end
    end

    local function getSprinklerPlacementPosition(basePos)
        if typeof(basePos) ~= "Vector3" then
            return basePos
        end
        local rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        local rayBlacklist = {}
        if player.Character then
            table.insert(rayBlacklist, player.Character)
        end
        if clientPlants then
            table.insert(rayBlacklist, clientPlants)
        end
        rayParams.FilterDescendantsInstances = rayBlacklist

        -- Try beside-plant positions first, then center as fallback.
        local candidateOffsets = {
            Vector3.new(2.2, 0, 0),
            Vector3.new(-2.2, 0, 0),
            Vector3.new(0, 0, 2.2),
            Vector3.new(0, 0, -2.2),
            Vector3.new(1.6, 0, 1.6),
            Vector3.new(-1.6, 0, 1.6),
            Vector3.new(1.6, 0, -1.6),
            Vector3.new(-1.6, 0, -1.6),
            Vector3.new(0, 0, 0),
        }

        for _, offset in ipairs(candidateOffsets) do
            local candidate = basePos + offset
            local rayResult = workspace:Raycast(candidate + Vector3.new(0, 8, 0), Vector3.new(0, -40, 0), rayParams)
            if rayResult then
                return rayResult.Position + Vector3.new(0, 0.15, 0)
            end
        end
        return basePos
    end

    for _, sprinklerName in ipairs(namesToUse) do
        if findAndEquipSprinklerTool(sprinklerName) then
            for _, pos in ipairs(targets) do
                local placePos = getSprinklerPlacementPosition(pos)
                local posValue = placePos
                if vector and type(vector.create) == "function" then
                    posValue = vector.create(placePos.X, placePos.Y, placePos.Z)
                end
                local ok, err = pcall(function()
                    local args = {
                        sprinklerName,
                        {
                            position = posValue
                        }
                    }
                    UseGearRemote:FireServer(unpack(args))
                end)
                if not ok then
                    warn("AutoSprinkler FireServer failed:", err)
                end
                task.wait(0.08)
            end
        end
    end
end

-- Auto Plant Function
function autoPlantSeeds(selectedSeeds)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local pos = player.Character.HumanoidRootPart.Position
        local seedsTable = (type(selectedSeeds) == "table") and selectedSeeds or {}
        for seedName, enabled in pairs(seedsTable) do
            if enabled then
                local equipped, plantType = findAndEquipSeedTool(seedName)
                if equipped and type(plantType) == "string" and plantType ~= "" then
                    for x=-4,4,2 do
                        for z=-4,4,2 do
                            pcall(function()
                                PlantRemote:InvokeServer(plantType, pos + Vector3.new(x, -3, z))
                            end)
                        end
                    end
                end
            end
        end
    end
end

local GearDropdown = ShopSection:Dropdown({
    Title = "Gear Item",
    Desc = "Select gear to auto-buy",
    Values = gearDropdownValues,
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedGearItem = normalizeMultiSelection(option, gearList)
    end,
})
trackConfigElement("GearDropdown", GearDropdown)
ShopSection:Space()

local AutoBuyGearToggle = ShopSection:Toggle({
    Title = "Auto Buy Gear",
    Desc = "Automatically purchase selected gear",
    Icon = "check",
    Value = false,
    Callback = function(state)
        autoBuyGear = state
        WindUI:Notify({ Title = "Shop", Content = (state and "Auto-buy gear enabled" or "Auto-buy gear disabled"), Icon = "info", Duration = 2 })
        if state and not gearBuyLoopRunning then
            gearBuyLoopRunning = true
            task.spawn(function()
                while autoBuyGear and scriptRunning do
                    -- If both are enabled, seed flow owns the cycle and runs gear after seed.
                    if autoBuySeed then
                        task.wait(0.2)
                    else
                        performShopAutoBuy(
                            "GearShop",
                            "GearShop",
                            "Gear Shop",
                            24,
                            selectedGearItem,
                            function(itemName)
                                return itemName
                            end
                        )
                        task.wait(shopCheckInterval)
                    end
                end
                gearBuyLoopRunning = false
            end)
        end
    end,
})
trackConfigElement("AutoBuyGearToggle", AutoBuyGearToggle)
ShopSection:Space()

local SeedDropdown = ShopSection:Dropdown({
    Title = "Seed Item",
    Desc = "Select seed to auto-buy",
    Values = seedDropdownValues,
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedSeedItem = normalizeMultiSelection(option, seedList)
    end,
})
trackConfigElement("SeedDropdown", SeedDropdown)
ShopSection:Space()

local AutoBuySeedToggle = ShopSection:Toggle({
    Title = "Auto Buy Seed",
    Desc = "Automatically purchase selected seed",
    Icon = "check",
    Value = false,
    Callback = function(state)
        autoBuySeed = state
        WindUI:Notify({ Title = "Shop", Content = (state and "Auto-buy seed enabled" or "Auto-buy seed disabled"), Icon = "info", Duration = 2 })
        if state and not seedBuyLoopRunning then
            seedBuyLoopRunning = true
            task.spawn(function()
                while autoBuySeed and scriptRunning do
                    -- 1) Seed shop cycle first (teleport there and return).
                    performShopAutoBuy(
                        "SeedShop",
                        "SeedShop",
                        "Seed Shop",
                        43,
                        selectedSeedItem,
                        function(itemName)
                            return tostring(itemName):gsub("%s*Seed$", "")
                        end
                    )

                    -- 2) After seed cycle fully returns, run gear cycle.
                    if autoBuyGear then
                        while shopBuyProcessing do
                            task.wait(0.05)
                        end
                        performShopAutoBuy(
                            "GearShop",
                            "GearShop",
                            "Gear Shop",
                            24,
                            selectedGearItem,
                            function(itemName)
                                return itemName
                            end
                        )
                    end
                    task.wait(shopCheckInterval)
                end
                seedBuyLoopRunning = false
            end)
        end
    end,
})
trackConfigElement("AutoBuySeedToggle", AutoBuySeedToggle)
ShopSection:Space()

-- Fruit dropdown moved to Automation tab (so selection sits with Auto Sell toggle)

-- Refresh buttons and delay slider removed per user request

-- Automation tab: move automation-related toggles here
local AutomationTab = Window:Tab({
    Title = "Automation",
    Icon = "play",
    Locked = false,
})

local SellAutomationSection = AutomationTab:Section({ Title = "Sell Automation", Opened = true })
local FruitDropdown = SellAutomationSection:Dropdown({
    Title = "Fruit Type",
    Desc = "Select fruit origins to auto-sell",
    Values = fruitDropdownValues,
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedFruitItem = normalizeMultiSelection(option, fruitList)
    end,
})
trackConfigElement("FruitDropdown", FruitDropdown)

local FruitSellAmountInput = SellAutomationSection:Input({
    Title = "Fruit Items to Sell",
    Desc = "How many selected fruits to sell each batch",
    Value = tostring(fruitSellAmount),
    Placeholder = "e.g. 10",
    Type = "Input",
    Callback = function(value)
        fruitSellAmount = math.max(1, tonumber(value) or fruitSellAmount)
    end,
})
trackConfigElement("FruitSellAmountInput", FruitSellAmountInput)

local AutoSellFruitToggle = SellAutomationSection:Toggle({
    Title = "Auto Sell Fruit",
    Desc = "Automatically sell manually selected fruits",
    Icon = "check",
    Value = false,
    Callback = function(state)
        if state then
            local hasFruitSelection = selectedFruitItem and type(selectedFruitItem) == "table" and #selectedFruitItem > 0
            if not hasFruitSelection then
                WindUI:Notify({ Title = "Automation", Content = "Select fruits first!", Icon = "alert-triangle", Duration = 2 })
                autoSellFruit = false
                return
            end
        end
        autoSellFruit = state
        WindUI:Notify({ Title = "Automation", Content = (state and "Auto-sell fruit enabled" or "Auto-sell fruit disabled"), Icon = "info", Duration = 2 })
    end,
})
trackConfigElement("AutoSellFruitToggle", AutoSellFruitToggle)
SellAutomationSection:Space()

local FruitRarityDropdown = SellAutomationSection:Dropdown({
    Title = "Fruit Rarity",
    Desc = "Select rarities to auto-sell",
    Values = rarityDropdownValues,
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedFruitRarities = toSelectionSet(option, rarityList)
    end,
})
trackConfigElement("FruitRarityDropdown", FruitRarityDropdown)

local RaritySellAmountInput = SellAutomationSection:Input({
    Title = "Rarity Items to Sell",
    Desc = "How many rarity-matched fruits to sell each batch",
    Value = tostring(raritySellAmount),
    Placeholder = "e.g. 10",
    Type = "Input",
    Callback = function(value)
        raritySellAmount = math.max(1, tonumber(value) or raritySellAmount)
    end,
})
trackConfigElement("RaritySellAmountInput", RaritySellAmountInput)

local AutoSellRarityToggle = SellAutomationSection:Toggle({
    Title = "Auto Sell Rarity",
    Desc = "Automatically sell fruits from selected rarities",
    Icon = "check",
    Value = false,
    Callback = function(state)
        if state and not hasSelection(selectedFruitRarities) then
            WindUI:Notify({ Title = "Automation", Content = "Select rarities first!", Icon = "alert-triangle", Duration = 2 })
            autoSellRarity = false
            return
        end
        autoSellRarity = state
        WindUI:Notify({ Title = "Automation", Content = (state and "Auto-sell rarity enabled" or "Auto-sell rarity disabled"), Icon = "info", Duration = 2 })
    end,
})
trackConfigElement("AutoSellRarityToggle", AutoSellRarityToggle)
SellAutomationSection:Space()

local AutoSellAllToggle = SellAutomationSection:Toggle({
    Title = "Auto Sell When Backpack Full",
    Desc = "Auto-sell when fruit backpack is full",
    Icon = "check",
    Value = false,
    Callback = function(state)
        autoSellAll = state
        WindUI:Notify({ Title = "Automation", Content = (state and "Auto-sell all enabled" or "Auto-sell all disabled"), Icon = "info", Duration = 2 })
    end,
})
trackConfigElement("AutoSellAllToggle", AutoSellAllToggle)
SellAutomationSection:Space()

local PlantAutomationSection = AutomationTab:Section({ Title = "Plant Automation", Opened = true })
local SeedAutoDropdown = PlantAutomationSection:Dropdown({
    Title = "Seeds to Plant",
    Desc = "Choose which seeds to auto-plant",
    Values = plantSeedDropdownValues,
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedSeeds = toSelectionSet(option, plantSeedList)
    end,
})
trackConfigElement("SeedAutoDropdown", SeedAutoDropdown)

local AutoPlantToggle = PlantAutomationSection:Toggle({
    Title = "Auto Plant",
    Desc = "Automatically plant selected seeds around you",
    Value = false,
    Callback = function(state)
        if state and not hasSelection(selectedSeeds) then
            WindUI:Notify({ Title = "Automation", Content = "Select seeds first!", Icon = "alert-triangle", Duration = 2 })
            autoPlant = false
            return
        end
        autoPlant = state
        WindUI:Notify({ Title = "Automation", Content = (state and "Auto-plant enabled" or "Auto-plant disabled"), Icon = "info", Duration = 2 })
    end,
})
trackConfigElement("AutoPlantToggle", AutoPlantToggle)
PlantAutomationSection:Space()

local WaterAutomationSection = AutomationTab:Section({ Title = "Water Automation", Opened = true })
local waterPlantValues = {}
if PlantsModels then
    for _, model in ipairs(PlantsModels:GetChildren()) do
        table.insert(waterPlantValues, model.Name)
    end
    table.sort(waterPlantValues)
end
if #waterPlantValues == 0 then
    waterPlantValues = {
        "Carrot","Tomato","Potato","Wheat","Pumpkin","Corn","Strawberry","Blueberry","Onion","Garlic","Cabbage","Banana","Apple","Plum","Cherry","Mushroom","Rose",
        "Dandelion","Bellpepper","Birch","Orange","Olive","Sunpetal","Goldenberry","Amberpine","Emberwood","Dawnblossom"
    }
end
do
    local seen = {}
    for _, name in ipairs(waterPlantValues) do
        seen[name] = true
    end
    for _, name in ipairs(fruitList) do
        if not seen[name] then
            seen[name] = true
            table.insert(waterPlantValues, name)
        end
    end
    table.sort(waterPlantValues)
end

local WaterPlantDropdown = WaterAutomationSection:Dropdown({
    Title = "Select Plant to Water",
    Desc = "Choose plant types to auto-water",
    Values = withAllOption(waterPlantValues),
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedWaterPlants = toSelectionSet(option, waterPlantValues)
    end,
})
trackConfigElement("WaterPlantDropdown", WaterPlantDropdown)

local AutoWaterToggle = WaterAutomationSection:Toggle({
    Title = "Auto Water Selected Plant",
    Desc = "Equip Watering Can and water the plant",
    Value = false,
    Callback = function(state)
        if state and not hasSelection(selectedWaterPlants) then
            WindUI:Notify({ Title = "Automation", Content = "Select plants to water first!", Icon = "alert-triangle", Duration = 2 })
            autoWater = false
            return
        end
        autoWater = state
        WindUI:Notify({ Title = "Automation", Content = (state and "Auto-water enabled" or "Auto-water disabled"), Icon = "info", Duration = 2 })
    end,
})
trackConfigElement("AutoWaterToggle", AutoWaterToggle)
WaterAutomationSection:Space()

local SeedPackAutomationSection = AutomationTab:Section({ Title = "Seed Pack Automation", Opened = true })
local SeedPackDropdown = SeedPackAutomationSection:Dropdown({
    Title = "Seed Pack",
    Desc = "Select seed packs to auto-open",
    Values = seedPackDropdownValues,
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedSeedPackItem = normalizeMultiSelection(option, seedPackList)
    end,
})
trackConfigElement("SeedPackDropdown", SeedPackDropdown)

local AutoSeedPackToggle = SeedPackAutomationSection:Toggle({
    Title = "Auto Open Seed Pack",
    Desc = "Equip selected seed pack and open",
    Value = false,
    Callback = function(state)
        if state and (not selectedSeedPackItem or #selectedSeedPackItem == 0) then
            WindUI:Notify({ Title = "Automation", Content = "Select seed pack first!", Icon = "alert-triangle", Duration = 2 })
            autoOpenSeedPack = false
            return
        end
        autoOpenSeedPack = state
        WindUI:Notify({ Title = "Automation", Content = (state and "Auto-open seed pack enabled" or "Auto-open seed pack disabled"), Icon = "info", Duration = 2 })
    end,
})
trackConfigElement("AutoSeedPackToggle", AutoSeedPackToggle)
SeedPackAutomationSection:Space()

local SprinklerAutomationSection = AutomationTab:Section({ Title = "Sprinkler Automation", Opened = true })
local SprinklerGearDropdown = SprinklerAutomationSection:Dropdown({
    Title = "Sprinkler Type",
    Desc = "Select sprinkler gear(s) to use",
    Values = sprinklerGearList,
    Value = selectedSprinklerGear,
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedSprinklerGear = normalizeMultiSelection(option, sprinklerGearList)
    end,
})
trackConfigElement("SprinklerGearDropdown", SprinklerGearDropdown)

local SprinklerPlantDropdown = SprinklerAutomationSection:Dropdown({
    Title = "Select Plant to Sprinkler",
    Desc = "Choose plant types to auto-sprinkler",
    Values = withAllOption(waterPlantValues),
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedSprinklerPlants = toSelectionSet(option, waterPlantValues)
    end,
})
trackConfigElement("SprinklerPlantDropdown", SprinklerPlantDropdown)

local AutoSprinklerToggle = SprinklerAutomationSection:Toggle({
    Title = "Auto Sprinkler Selected Plant",
    Desc = "Use selected sprinkler at selected plant positions",
    Value = false,
    Callback = function(state)
        if state and (type(selectedSprinklerGear) ~= "table" or #selectedSprinklerGear == 0) then
            WindUI:Notify({ Title = "Automation", Content = "Select sprinkler type(s) first!", Icon = "alert-triangle", Duration = 2 })
            autoSprinkler = false
            return
        end
        if state and not hasSelection(selectedSprinklerPlants) then
            WindUI:Notify({ Title = "Automation", Content = "Select plants to sprinkler first!", Icon = "alert-triangle", Duration = 2 })
            autoSprinkler = false
            return
        end
        autoSprinkler = state
        WindUI:Notify({ Title = "Automation", Content = (state and "Auto-sprinkler enabled" or "Auto-sprinkler disabled"), Icon = "info", Duration = 2 })
    end,
})
trackConfigElement("AutoSprinklerToggle", AutoSprinklerToggle)
SprinklerAutomationSection:Space()

local HarvestAutomationSection = AutomationTab:Section({ Title = "Harvest Automation", Opened = true })
local plantValues = {}
if PlantsModels then
    for _, model in ipairs(PlantsModels:GetChildren()) do
        table.insert(plantValues, model.Name)
    end
    table.sort(plantValues)
end
if #plantValues == 0 then
    plantValues = {
        "Carrot","Tomato","Potato","Wheat","Pumpkin","Corn","Strawberry","Blueberry","Onion","Garlic","Cabbage","Banana","Apple","Plum","Cherry","Mushroom","Rose",
        "Dandelion","Bellpepper","Birch","Orange","Olive","Sunpetal","Goldenberry","Amberpine","Emberwood","Dawnblossom"
    }
end
do
    local seen = {}
    for _, name in ipairs(plantValues) do
        seen[name] = true
    end
    for _, name in ipairs(fruitList) do
        if not seen[name] then
            seen[name] = true
            table.insert(plantValues, name)
        end
    end
    table.sort(plantValues)
end
local plantDropdownValues = withAllOption(plantValues)

local PlantAutoDropdown = HarvestAutomationSection:Dropdown({
    Title = "Plants to Harvest",
    Desc = "Choose plant types to auto-harvest",
    Values = plantDropdownValues,
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedPlants = toSelectionSet(option, plantValues)
    end,
})
trackConfigElement("PlantAutoDropdown", PlantAutoDropdown)

local RipenessDropdown = HarvestAutomationSection:Dropdown({
    Title = "Fruit Ripeness",
    Desc = "Select ripeness stages to auto-harvest fruits",
    Values = ripenessDropdownValues,
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedRipenessStages = toSelectionSet(option, ripenessStageList)
    end,
})
trackConfigElement("RipenessDropdown", RipenessDropdown)

local VariantDropdown = HarvestAutomationSection:Dropdown({
    Title = "Fruit Variant",
    Desc = "Select variants to auto-harvest fruits",
    Values = fruitVariantDropdownValues,
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedFruitVariants = toSelectionSet(option, fruitVariantList)
    end,
})
trackConfigElement("VariantDropdown", VariantDropdown)

local MutationDropdown = HarvestAutomationSection:Dropdown({
    Title = "Fruit Mutation",
    Desc = "Select mutations to auto-harvest fruits",
    Values = fruitMutationDropdownValues,
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedFruitMutations = toSelectionSet(option, fruitMutationList)
    end,
})
trackConfigElement("MutationDropdown", MutationDropdown)

local AutoHarvestToggle = HarvestAutomationSection:Toggle({
    Title = "Auto Harvest",
    Desc = "Harvest by selected plants and/or ripeness stages and/or Variant",
    Value = false,
    Callback = function(state)
        local hasPlantSelection = hasSelection(selectedPlants)
        local hasStageSelection = hasSelection(selectedRipenessStages)
        local hasVariantSelection = hasSelection(selectedFruitVariants)
        local hasMutationSelection = hasSelection(selectedFruitMutations)
        if state and (not hasPlantSelection and not hasStageSelection and not hasVariantSelection and not hasMutationSelection) then
            WindUI:Notify({ Title = "Automation", Content = "Select plants, ripeness, variant, or mutation first!", Icon = "alert-triangle", Duration = 2 })
            autoHarvest = false
            return
        end
        autoHarvest = state
        WindUI:Notify({ Title = "Automation", Content = (state and "Auto-harvest enabled" or "Auto-harvest disabled"), Icon = "info", Duration = 2 })
    end,
})
trackConfigElement("AutoHarvestToggle", AutoHarvestToggle)

-- fast-harvest toggle
local FastHarvestToggle = HarvestAutomationSection:Toggle({
    Title = "Fast Harvest",
    Desc = "Ultra-fast harvesting using proximity prompts (requires Auto Harvest)",
    Value = false,
    Callback = function(state)
        FastHarvestEnabled = state
        WindUI:Notify({ Title = "Automation", Content = (state and "Fast harvest enabled" or "Fast harvest disabled"), Icon = "info", Duration = 2 })
    end,
})
trackConfigElement("FastHarvestToggle", FastHarvestToggle)

HarvestAutomationSection:Space()

local ShovelFruitDropdown = HarvestAutomationSection:Dropdown({
    Title = "Select Fruit To Shovel",
    Desc = "Choose fruit types to shovel",
    Values = fruitDropdownValues,
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedShovelFruits = toSelectionSet(option, fruitList)
    end,
})
trackConfigElement("ShovelFruitDropdown", ShovelFruitDropdown)

local ShovelPlantDropdown = HarvestAutomationSection:Dropdown({
    Title = "Select Plant To Shovel",
    Desc = "Choose plant types to shovel",
    Values = withAllOption(fruitList),
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        selectedShovelPlants = toSelectionSet(option, fruitList)
    end,
})
trackConfigElement("ShovelPlantDropdown", ShovelPlantDropdown)

local AutoShovelToggle = HarvestAutomationSection:Toggle({
    Title = "Auto Shovel",
    Desc = "Auto shovel selected fruit or plant types",
    Value = false,
    Callback = function(state)
        local hasFruitSelection = hasSelection(selectedShovelFruits)
        local hasPlantSelection = hasSelection(selectedShovelPlants)
        if state and (not hasFruitSelection and not hasPlantSelection) then
            WindUI:Notify({ Title = "Automation", Content = "Select shovel fruit or plant first!", Icon = "alert-triangle", Duration = 2 })
            autoShovel = false
            return
        end
        autoShovel = state
        WindUI:Notify({ Title = "Automation", Content = (state and "Auto-shovel enabled" or "Auto-shovel disabled"), Icon = "info", Duration = 2 })
    end,
})
trackConfigElement("AutoShovelToggle", AutoShovelToggle)
HarvestAutomationSection:Space()

refreshConfigDropdown()
if autoLoadConfigFile then
    local autoConfigName = sanitizeConfigName(autoLoadConfigFile)
    if autoConfigName ~= "" then
        local configObj = ConfigManager:CreateConfig(autoConfigName)
        registerConfigElements(configObj)
        local ok, err = pcall(function()
            configObj:Load()
        end)
        if ok then
            selectedConfigFile = autoConfigName
            WindUI:Notify({ Title = "Config", Content = "Auto-loaded: " .. autoConfigName .. ".json", Icon = "check", Duration = 3 })
        else
            WindUI:Notify({ Title = "Config", Content = "Auto-load failed: " .. tostring(err), Icon = "alert-triangle", Duration = 3 })
        end
    end
end

    
    

    
-- fruit auto-sell loop
task.spawn(function()
    while scriptRunning do
        local hasFruitSelection = selectedFruitItem and type(selectedFruitItem) == "table" and #selectedFruitItem > 0
        local hasRaritySelection = hasSelection(selectedFruitRarities)
        if (autoSellFruit and hasFruitSelection) or (autoSellRarity and hasRaritySelection) then
            local sellAmountByFruit = {}
            if autoSellFruit and hasFruitSelection then
                for _, fruit in ipairs(selectedFruitItem) do
                    if type(fruit) == "string" then
                        sellAmountByFruit[fruit] = fruitSellAmount
                    end
                end
            end
            if autoSellRarity and hasRaritySelection then
                for _, fruit in ipairs(getRarityFruitList(selectedFruitRarities)) do
                    if type(fruit) == "string" then
                        local existing = sellAmountByFruit[fruit]
                        if existing then
                            sellAmountByFruit[fruit] = math.max(existing, raritySellAmount)
                        else
                            sellAmountByFruit[fruit] = raritySellAmount
                        end
                    end
                end
            end
            performAutoSellSingleBatch(sellAmountByFruit)
            task.wait(fruitSellInterval)
        else
            task.wait(1)
        end
    end
end)

-- auto open seed pack loop
task.spawn(function()
    while scriptRunning do
        if autoOpenSeedPack and selectedSeedPackItem and #selectedSeedPackItem > 0 then
            for _, packName in ipairs(selectedSeedPackItem) do
                local ok, err = pcall(function()
                    if findAndEquipSeedPackTool(packName) then
                        SpinRemote:InvokeServer()
                    end
                end)
                if not ok then
                    warn("Error opening seed pack", packName, err)
                end
                task.wait(0.25)
            end
            task.wait(seedPackOpenInterval)
        else
            task.wait(0.5)
        end
    end
end)

-- auto sell-all watcher (driven by inventory-full notification text)
task.spawn(function()
    while scriptRunning do
        if autoSellAll and not autoSellProcessing then
            local now = os.clock()
            if (now - lastAutoSellAllAt) >= autoSellAllCooldown then
                if performAutoSellAll() then
                    lastAutoSellAllAt = now
                    harvestStallCount = 0
                end
            end
        end
        task.wait(0.2)
    end
end)

-- auto plant/harvest loop

-- stop harvesting when player respawns (reset toggles)
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    if AutoHarvestToggle then AutoHarvestToggle:Set(false) end
    if FastHarvestToggle then FastHarvestToggle:Set(false) end
    autoHarvest = false
    FastHarvestEnabled = false
end

task.spawn(function()
    while scriptRunning do
        if autoPlant then
            autoPlantSeeds(selectedSeeds)
        end
        if autoHarvest then
            local beforeCount = countHarvestedFruitTools()
            local harvestAttempts = 0

            if FastHarvestEnabled then
                for _, obj in pairs(workspace:GetDescendants()) do
                    if obj:IsA("ProximityPrompt") then
                        local parent = obj.Parent
                        if parent and parent.Name:match("Crop") and obj.Enabled then
                            fireproximityprompt(obj)
                            harvestAttempts = harvestAttempts + 1
                            task.wait(0.01)
                        end
                    end
                end
            else
                harvestAttempts = autoHarvestPlants(selectedPlants, selectedRipenessStages, selectedFruitVariants, selectedFruitMutations)
            end

            task.wait(0.1)
            local afterCount = countHarvestedFruitTools()

            if autoSellAll and harvestAttempts > 0 and afterCount <= beforeCount then
                harvestStallCount = harvestStallCount + 1
                if harvestStallCount >= harvestStallThreshold then
                    if performAutoSellAll() then
                        harvestStallCount = 0
                    end
                end
            else
                harvestStallCount = 0
            end
        end
        if autoShovel then
            autoShovelTargets(selectedShovelFruits, selectedShovelPlants)
        end
        if autoWater then
            autoWaterPlants(selectedWaterPlants)
        end
        if autoSprinkler then
            autoSprinklerPlants(selectedSprinklerPlants, selectedSprinklerGear)
        end
        task.wait(plantInterval)
    end
end)


local AboutTab = Window:Tab({
    Title = "About",
    Icon = "lucide:notebook-text",
    Locked = false,
})


-- ================= ABOUT TAB =================

AboutTab:Divider()

-- Credits section below image
AboutTab:Paragraph({
    Title = "Credits",
    Desc = "Script Developer: Xuan | UI Library: WindUI | Community: Kayden's Den Discord Server\n\nThank you for using Xuan Hub! Special thanks to all contributors and testers.",
    TextXAlignment = "Center",
    TextSize = 15,
})

AboutTab:Divider()

-- Discord section below credits
AboutTab:Paragraph({
    Title = "Join our discord server!", 
    Desc = "Join our Discord for updates, giveaways, questions, support and more!",
    TextXAlignment = "Center",
    TextSize = 17,
})

local InviteCode = "kaydensdens"

AboutTab:Paragraph({
    Title = "Discord Server",
    Desc = "discord.gg/" .. InviteCode,
})

AboutTab:Button({
    Title = "Copy Discord Invite",
    Callback = function()
        if setclipboard then
            setclipboard("https://discord.gg/" .. InviteCode)
            WindUI:Notify({ Title = "Discord", Content = "Invite link copied!", Icon = "check", Duration = 2 })
        else
            warn("setclipboard() not available in this environment.")
            WindUI:Notify({ Title = "Discord", Content = "Clipboard not supported", Icon = "alert-triangle", Duration = 2 })
        end
    end
})

-- Set Base tab as default
AboutTab:Select()

-- ================= FINALIZE =================
WindUI:Notify({
    Title = "Xuan Hub Loaded",
    Content = "Welcome " .. player.DisplayName .. "!",
    Icon = "check",
    Duration = 5,
})
