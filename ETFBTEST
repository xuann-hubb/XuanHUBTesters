-- ================= XUAN HUB GUI (WindUI Version) =================
-- Disabled PlaceId check for testing
-- if game.PlaceId ~= 131623223084840 then
--     game:GetService("Players").LocalPlayer:Kick("Xuan Hub not supported this game!")
--     return
-- end

print("--===== XUAN HUB LOADED (WindUI) =====--")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- ================= LOAD WINDUI =================
local WindUI = loadstring(game:HttpGet(
    "https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"
))()

-- ================= SET FONT (IMPORTANT) =================
-- WindUI text font
WindUI:SetFont("rbxasset://fonts/families/GothamSSm.json")

-- ================= ADD CUSTOM HOLOGRAPHIC THEME =================
WindUI:AddTheme({
    Name = "Holographic", -- theme name

    Accent = WindUI:Gradient({
        ["0"] = { Color = Color3.fromHex("#1ABC9C"), Transparency = 0 },   -- Teal start
        ["50"] = { Color = Color3.fromHex("#3498DB"), Transparency = 0 },  -- Blue middle
        ["100"] = { Color = Color3.fromHex("#9B59B6"), Transparency = 0 }, -- Purple end
    }, {
        Rotation = 45,
    }),
    Outline = Color3.fromHex("#1ABC9C"),     -- Holographic teal outline
    Text = Color3.fromHex("#FFFFFF"),        -- Pure white text
    Placeholder = Color3.fromHex("#7F8C8D"), -- Gray placeholder
    Button = Color3.fromHex("#E70AD5"),      -- Darker holographic teal
    Icon = Color3.fromHex("#3DFFDC"),        -- Light holographic cyan
})


-- ================= SETTINGS PERSISTENCE =================
local settingsFileName = "XuanHubConfig_ETFB.json"
local defaultSettings = {
    autoCollectMoney = false,
    autoCollectRadioactive = false,
    autoSpin = false,
    spinDelay = 0.5,
    autoUpgradeBase = false,
    autoUpgradeCarry = false,
    autoUpgradeSpeed = false,
    autoUpgradeJump = false,
    upgradeSpeedAmount = 1,
    autoRebirth = false,
    autoObby = false,
    -- UFO Event
    autoCollectUFO = false,
    -- UFO Spin
    autoSpinUFO = false,
    -- Money wheel spin
    autoSpinMoneyWheel = false,
    -- Money Event (Gold Bar)
    autoCollectGoldBar = false,
    -- Money Obby Auto Complete
    autoCompleteMoneyObby = false,
    -- Arcade Event
    autoCollectGameConsole = false,
    autoCollectArcadeTicket = false,
    autoSpinArcadeWheel = false,
    -- Valentines Event
    autoCollectCandy = false,
    autoCollectValentinesCoin = false,
    autoSpinValentinesWheel = false,
    -- Auto-open Lucky Block (select which lucky block to auto-open from your Backpack)
    autoOpenLuckyBlock = false,
    autoOpenLuckyBlockTarget = "Radioactive Block",
    autoOpenLuckyBlockDelay = 0.6,
    -- When true, rejoin the server automatically after completing the 3 Money Obby cycles
    autoRejoinAfterMoneyObby = false,
    -- Unlock Zoom
    unlockZoom = false,
    -- Tsunami tracker
    autoTsunamiTracker = false,
    -- Auto-teleport by rarity (Tsunami) — maps rarities to gap indices
    autoTeleportByRarity = false,
    autoTeleportByRarityTarget = "Common",
    -- Wider hitbox (tool reach)
    hitboxEnabled = false,
    hitboxWidth = 70,
    -- Auto Sell by Rarity
    autoSellByRarity = false,
    -- Auto Remove VIP Walls
    autoRemoveVIPWalls = false,
    sellRarities = {},
}

local function loadSettings()
    if not isfolder("XuanHub") then
        makefolder("XuanHub")
    end

    if isfile("XuanHub/" .. settingsFileName) then
        local success, data = pcall(function()
            return HttpService:JSONDecode(readfile("XuanHub/" .. settingsFileName))
        end)
        if success and data then
            return data
        end
    end

    -- no settings file or parse failed: return a safe copy of defaults
    local ok, copy = pcall(function()
        return HttpService:JSONDecode(HttpService:JSONEncode(defaultSettings))
    end)
    if ok and type(copy) == "table" then
        return copy
    end

    return defaultSettings
end

local function saveSettings(settings)
    pcall(function()
        if not isfolder("XuanHub") then
            makefolder("XuanHub")
        end
        writefile("XuanHub/" .. settingsFileName, HttpService:JSONEncode(settings))
    end)
end

local savedSettings = loadSettings()

-- ================= CREATE WINDUI WINDOW =================
local Window = WindUI:CreateWindow({
    Folder = "XuanHub",
    Title = "XUAN HUB",
    Author = "by discord.gg/kaydensdens",
    Icon = "rbxassetid://103326199885496",
    Theme = "Holographic", -- Use custom holographic theme
    Size = UDim2.fromOffset(640, 480),
    Draggable = true,
    HasOutline = true,
    HideSearchBar = false,
    OutlineThickness = 3,
    Resizable = true,
    Transparent = true,
    User = {
        Enabled = true,
    },


})


Window:EditOpenButton({
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

-- Add version tag with FPS and Ping counter
local version = game.PlaceVersion -- Server version
local fps = 0
local ping = 0
local Stats = game:GetService("Stats")

local VersionTag = Window:Tag({
    Title = string.format("v%d | Ping: 0 | FPS: 0", version),
    Icon = "solar:server-bold",
    Color = Color3.fromRGB(255, 105, 180), -- Pink color
    Border = true,
})

local frames = 0
local last = os.clock()

RunService.RenderStepped:Connect(function()
    frames = frames + 1
    local now = os.clock()
    if now - last >= 1 then
        fps = frames
        frames = 0
        last = now

        -- Get ping
        pcall(function()
            local item = Stats.Network.ServerStatsItem:FindFirstChild("Data Ping")
            if item then
                ping = math.floor(item:GetValue())
            end
        end)

        -- Update tag
        VersionTag:SetTitle(string.format("v%d | Ping: %d | FPS: %d", version, ping, fps))
    end
end)

-- ================= TABS =================

-- Helper function for gradient text
local function gradient(text, colorFrom, colorTo)
    local result = ""
    local len = #text
    for i = 1, len do
        local ratio = (i - 1) / math.max(len - 1, 1)
        local r = colorFrom.R + (colorTo.R - colorFrom.R) * ratio
        local g = colorFrom.G + (colorTo.G - colorFrom.G) * ratio
        local b = colorFrom.B + (colorTo.B - colorFrom.B) * ratio
        local color = Color3.new(r, g, b)
        local hex = string.format("#%02x%02x%02x", math.floor(color.R * 255), math.floor(color.G * 255),
            math.floor(color.B * 255))
        result = result .. string.format('<font color="%s">%s</font>', hex, text:sub(i, i))
    end
    return result
end

local BaseTab = Window:Tab({
    Title = "Main",
    Icon = "layers-2",
    Locked = false,
})

local EventTab = Window:Tab({
    Title = "Event",
    Icon = "star",
    Locked = false,
})

local AutoTab = Window:Tab({
    Title = "Auto",
    Icon = "refresh-cw",
    Locked = false,
})

local TsunamiTab = Window:Tab({
    Title = "Tsunami",
    Icon = "cloud-lightning",
    Locked = false,
})

local GearTab = Window:Tab({
    Title = "Gear Shop",
    Icon = "shopping-bag",
    Locked = false,
})

local MiscTab = Window:Tab({
    Title = "Settings",
    Icon = "settings",
    Locked = false,
})

local MachineTab = Window:Tab({
    Title = "Machine",
    Icon = "box",
    Locked = false,
})

local AboutTab = Window:Tab({
    Title = "About",
    Icon = "lucide:notebook-text",
    Locked = false,
})

-- ================= GEAR SHOP =================
local GearSection = GearTab:Section({ Title = "Gear Shop", Opened = true })

-- Function to fetch gear data from game module
local function getGearListFromModule()
    local gearList = {}
    local gearNameMapping = {}
    
    pcall(function()
        local GearModule = require(game:GetService("ReplicatedStorage").SharedModules.GearModule)
        
        if GearModule and GearModule.GearNames then
            -- Build gear array with cost and description
            for _, gearName in ipairs(GearModule.GearNames) do
                local cost = GearModule.Costs[gearName]
                local desc = GearModule.Descriptions[gearName] or ""
                
                -- Only include items with a defined cost
                if cost then
                    local displayLabel = string.format("%s - $%s%s", 
                        gearName, 
                        tostring(cost),
                        desc ~= "" and " (" .. desc .. ")" or "")
                    
                    table.insert(gearList, displayLabel)
                    gearNameMapping[displayLabel] = gearName
                end
            end
        end
    end)
    
    return gearList, gearNameMapping
end

-- Get all available gear
local allGears, gearNameMapping = getGearListFromModule()
local selectedGears = {}

GearSection:Dropdown({
    Title = "Select Gear to Buy",
    Desc = "Select one or more gears to purchase",
    Values = allGears,
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(selected)
        selectedGears = selected
    end
})

GearSection:Button({
    Title = "Buy Selected Gears",
    Desc = "Purchase all selected gears",
    Locked = false,
    Callback = function()
        if #selectedGears == 0 then
            WindUI:Notify({ Title = "Gear Shop", Content = "No gears selected", Icon = "alert-triangle", Duration = 3 })
            return
        end
        
        local successCount = 0
        local failCount = 0
        
        for _, displayName in ipairs(selectedGears) do
            local gearName = gearNameMapping[displayName]
            if gearName then
                local success = pcall(function()
                    game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("BuyGear"):InvokeServer(gearName)
                end)
                if success then
                    successCount = successCount + 1
                else
                    failCount = failCount + 1
                end
                task.wait(0.1)
            end
        end
        
        if successCount > 0 then
            WindUI:Notify({ 
                Title = "Gear Shop", 
                Content = string.format("Purchased %d gear(s)", successCount), 
                Icon = "check", 
                Duration = 3 
            })
        end
        if failCount > 0 then
            WindUI:Notify({ 
                Title = "Gear Shop", 
                Content = string.format("%d purchase(s) failed", failCount), 
                Icon = "alert-triangle", 
                Duration = 3 
            })
        end
    end
})

-- ================= FUNCTIONALITY LOGIC =================

-- Script running flag (to stop all loops when GUI is closed)
-- Script running flag
local scriptRunning = true

-- Character references
local character, humanoidRootPart
local EventFolder = nil

-- Consolidated state table to reduce local variable count
local State = {
    -- Event collection
    PullDelay = 0.1,
    HeightOffset = 3,
    active = false,
    spinning = false,
    autoObby = false,
    collectingMoney = false,
    autoCollectRadioactive = false,
    autoCollectUFO = false,
    autoCollectGoldBar = false,
    autoCollectGameConsole = false,
    autoCollectArcadeTicket = false,
    autoSpinArcadeWheel = false,
    autoCollectCandy = false,
    autoCollectValentinesCoin = false,
    autoSpinValentinesWheel = false,
    autoSpinUFO = false,
    autoSpinMoneyWheel = false,
    
    -- Upgrades
    autoUpgradeBase = false,
    autoUpgradeCarry = false,
    autoUpgradeSpeed = false,
    upgradeSpeedAmount = 1,
    autoUpgradeJump = false,
    autoRebirth = false,
    
    -- Hitbox
    widerHitboxEnabled = false,
    widerHitboxWidth = 70,
    widerHitboxConn = nil,
    widerHitbox_tracking = {},
    
    -- Zoom
    unlockZoomEnabled = false,
    prevCameraMin = nil,
    prevCameraMax = nil,
    
    -- Flight
    flyMode = false,
    flyBodyVelocity = nil,
    flyConnection = nil,
    noclipConnection = nil,
    
    -- Obby/Events
    autoCompleteMoneyObby = false,
    
    -- Lucky Block
    autoOpenLuckyBlock = false,
    autoOpenLuckyBlockTarget = "Radioactive Block",
    autoOpenLuckyBlockDelay = 0.6,
    
    -- Selling
    autoSellByRarity = false,
    sellRarities = {},
    autoSellByName = false,
    sellBrainrotNames = {},
    selectedRarityForNames = "Common",
    lastSellAllClick = 0,
    
    -- VIP Walls
    autoRemoveVIPWalls = false,
    
    -- Brainrot
    autoUpgradeBrainrot = false,
    upgradeBrainrotTargets = {},
    brainrotSlotData = {},
    BrainrotUpgradeDropdown = nil,
    
    -- Machines
    autoMachine = false,
    machineTargetTime = "60:00",
    machineBrainrot1 = "",
    machineBrainrot2 = "",
    machineBrainrot3 = "",
    
    autoArcadeMachine = false,
    arcadeBrainrot1 = "",
    arcadeBrainrot2 = "",
    arcadeBrainrot3 = "",
    
    autoValentineMachine = false,
    valentineBrainrot1 = "",
    valentineBrainrot2 = "",
    valentineBrainrot3 = "",
    
    -- Tsunami
    autoTeleportByRarity = false,
    autoTeleportByRarityTarget = "Common",
}

-- Global machine flags
_G.ArcadeAutoSubmitActive = false
_G.ValentineAutoSubmitActive = false

-- Character handler (safe)
local function setupCharacter(char)
    character = char
    humanoidRootPart = char:WaitForChild("HumanoidRootPart", 10)
end

if player.Character then
    setupCharacter(player.Character)
end
player.CharacterAdded:Connect(setupCharacter)

-- Auto-Obby: finder that targets the new `RadioactiveMap_SharedInstances` layout
local function findRadioactiveRoot()
    -- primary: find the shared-instances container and locate the obby model inside it
    local rms = workspace:FindFirstChild("RadioactiveMap_SharedInstances")
    if rms then
        -- prefer a model that contains ObbyEnd or has 'Obby' in its name
        for _, d in ipairs(rms:GetDescendants()) do
            if d:IsA("Model") and (d:FindFirstChild("ObbyEnd") or d.Name:lower():find("obby")) then
                return d
            end
        end
        -- sometimes the obby is a direct child (e.g. Mud -> Obby); check first-level children
        for _, c in ipairs(rms:GetChildren()) do
            if c:IsA("Model") and c:FindFirstChild("ObbyEnd") then
                return c
            end
        end
    end

    -- fallback: top-level legacy names (kept minimal)
    local legacy = workspace:FindFirstChild("Radioactive") or workspace:FindFirstChild("RadioactiveMap")
    if legacy and legacy:IsA("Model") then
        return legacy
    end

    return nil
end

-- Find EventParts WITHOUT BLOCKING GUI
task.spawn(function()
    while not EventFolder and scriptRunning do
        EventFolder = workspace:FindFirstChild("EventParts")
        task.wait(1)
    end
end)

-- Model part
local function getModelPart(model)
    if model.PrimaryPart then return model.PrimaryPart end
    for _, v in ipairs(model:GetDescendants()) do
        if v:IsA("BasePart") then
            model.PrimaryPart = v
            return v
        end
    end
end

-- Loop to pull models
task.spawn(function()
    while scriptRunning do
        if active and humanoidRootPart and EventFolder then
            for _, model in ipairs(EventFolder:GetChildren()) do
                if model:IsA("Model") then
                    local part = getModelPart(model)
                    if part then
                        model:SetPrimaryPartCFrame(
                            CFrame.new(humanoidRootPart.Position + Vector3.new(0, HeightOffset, 0))
                        )
                    end
                end
            end
        end
        task.wait(PullDelay)
    end
end)

-- Auto Spin logic
task.spawn(function()
    while scriptRunning do
        if spinning then
            pcall(function()
                local args = { "Radioactive", false }
                game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
                    "RF/WheelSpin.Roll"):InvokeServer(unpack(args))
            end)
            -- Get delay from input box with validation
            local delayValue = tonumber(savedSettings.spinDelay) or 0.5
            if delayValue <= 0 then delayValue = 0.5 end
            task.wait(delayValue)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Collect Money logic
local function findMyBase()
    for _, base in ipairs(workspace:WaitForChild("Bases"):GetChildren()) do
        if base:IsA("Model") then
            local holder = base:GetAttribute("Holder")
            if holder and holder == player.UserId then
                return base
            end
        end
    end
    return nil
end

-- Improved teleport helpers
local lastTeleportTime = 0
local TELEPORT_COOLDOWN = 1 -- seconds

local function getHomePart(base)
    if not base then return nil end
    local home = base:FindFirstChild("Home")
    if home and home:IsA("BasePart") then return home end
    return nil
end

local function findSafeCFrame(targetCFrame, upOffset)
    upOffset = upOffset or 6
    local origin = targetCFrame.Position + Vector3.new(0, 20, 0)
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = { player.Character }
    params.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(origin, Vector3.new(0, -80, 0), params)
    if result and result.Position then
        return CFrame.new(result.Position + Vector3.new(0, upOffset, 0))
    end
    return targetCFrame + Vector3.new(0, upOffset, 0)
end

local function teleportToBaseSmooth()
    if tick() - lastTeleportTime < TELEPORT_COOLDOWN then
        WindUI:Notify({ Title = "Teleport", Content = "Teleport cooldown", Icon = "alert-triangle", Duration = 2 })
        return
    end
    lastTeleportTime = tick()

    local base = findMyBase()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        WindUI:Notify({ Title = "Teleport", Content = "Character not ready", Icon = "alert-triangle", Duration = 3 }); return
    end
    if not base then
        WindUI:Notify({ Title = "Teleport", Content = "No base found", Icon = "alert-triangle", Duration = 3 }); return
    end
    local home = getHomePart(base)
    if not home then
        WindUI:Notify({ Title = "Teleport", Content = "Base Home not found", Icon = "alert-triangle", Duration = 3 }); return
    end

    local targetCFrame = findSafeCFrame(home.CFrame, 6)
    local prevCanCollide = hrp.CanCollide
    pcall(function() hrp.CanCollide = false end)

    local ok, err = pcall(function()
        local tween = TweenService:Create(hrp, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            { CFrame = targetCFrame })
        tween:Play()
        tween.Completed:Wait()

        -- briefly disable FallingDown after arriving at base
        pcall(function()
            disableFallingForLocalCharacter(2)
        end)
    end)

    pcall(function() hrp.CanCollide = prevCanCollide end)

    if ok then
        WindUI:Notify({ Title = "Teleport", Content = "Teleported to base", Icon = "check", Duration = 3 })
    else
        WindUI:Notify({ Title = "Teleport", Content = "Teleport failed: " .. tostring(err), Icon = "alert-triangle", Duration = 3 })
    end
end

task.spawn(function()
    while scriptRunning do
        if collectingMoney then
            local myBase = findMyBase()
            if myBase then
                for i = 1, 30 do
                    pcall(function()
                        local args = {
                            "Collect Money",
                            myBase.Name,
                            tostring(i)
                        }
                        local PlotAction = game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild(
                            "Net"):WaitForChild("RF/Plot.PlotAction")
                        PlotAction:InvokeServer(unpack(args))
                    end)
                    task.wait(0.01)
                end
            end
            task.wait(0.1)
        else
            task.wait(0.5)
        end
    end
end)

-- Generic coin collector used by multiple events (UFO, Radioactive)
local function _collectCoinsFromSources(opts)
    -- opts:
    --   rootPart (required): humanoid root part to touch with
    --   folderCandidates: array of workspace child-names to inspect (optional)
    --   rootModel: an Instance whose descendants should be searched (optional)
    --   nameMatchers: array of lowercase substrings to match coin names (optional)
    --   delayBetween = seconds between individual touches (optional)
    local rootPart = opts.rootPart
    if not rootPart then return end
    local nameMatchers = opts.nameMatchers or {}
    local delayBetween = tonumber(opts.delayBetween) or 0.05

    local function matchesName(n)
        if not n then return false end
        local ln = tostring(n):lower()
        if #nameMatchers == 0 then return true end
        for _, m in ipairs(nameMatchers) do
            if ln:find(m, 1, true) then return true end
        end
        return false
    end

    local function tryCollectFromFolder(folder)
        if not folder then return end
        for _, coin in ipairs(folder:GetChildren()) do
            local ok, cname = pcall(function() return coin.Name end)
            if ok and matchesName(cname) then
                local hitbox = coin:FindFirstChild("Hitbox") or coin:FindFirstChildWhichIsA("BasePart")
                if hitbox and hitbox:IsA("BasePart") then
                    pcall(function()
                        firetouchinterest(rootPart, hitbox, 0)
                        firetouchinterest(rootPart, hitbox, 1)
                    end)
                    task.wait(delayBetween)
                end
            end
        end
    end

    -- 1) explicit folder candidates
    if opts.folderCandidates then
        for _, fname in ipairs(opts.folderCandidates) do
            local f = workspace:FindFirstChild(fname)
            if f then tryCollectFromFolder(f) end
        end
    end

    -- 2) explicit root model (search its descendants for parts matching)
    if opts.rootModel then
        for _, d in ipairs(opts.rootModel:GetDescendants()) do
            if d:IsA("BasePart") then
                local ok, nm = pcall(function() return d.Name end)
                if ok and (matchesName(nm) or d:FindFirstChild("TouchInterest") or d:FindFirstChildOfClass("TouchTransmitter")) then
                    pcall(function()
                        firetouchinterest(rootPart, d, 0)
                        firetouchinterest(rootPart, d, 1)
                    end)
                    task.wait(delayBetween)
                end
            end
        end
    end
end

-- Auto Collect UFO
task.spawn(function()
    while scriptRunning do
        if autoCollectUFO then
            pcall(function()
                local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                local folder = workspace:FindFirstChild("UFOEventParts") or workspace:FindFirstChild("UFQEventParts")
                if not hrp or not folder then return end

                for _, coin in ipairs(folder:GetChildren()) do
                    if coin.Name == "UFO Coin" or coin.Name:lower():find("coin") or coin.Name:lower():find("ufo") then
                        -- prefer the 'Hitbox' or 'hitbox' part
                        local hitboxPart = coin:FindFirstChild("Hitbox") or coin:FindFirstChild("hitbox")
                        if hitboxPart and hitboxPart:IsA("BasePart") then
                            pcall(function()
                                firetouchinterest(hrp, hitboxPart, 0)
                                firetouchinterest(hrp, hitboxPart, 1)
                            end)
                            task.wait(0.01)
                        else
                            -- fallback: find any BasePart descendant (or TouchInterest owner)
                            for _, d in ipairs(coin:GetDescendants()) do
                                if d:IsA("BasePart") and (d:FindFirstChild("TouchInterest") or d.Name:lower():find("hitbox") or d.Name:lower():find("coin")) then
                                    pcall(function()
                                        firetouchinterest(hrp, d, 0)
                                        firetouchinterest(hrp, d, 1)
                                    end)
                                    task.wait(0.01)
                                    break
                                end
                            end
                        end
                    end
                end
            end)
            task.wait(0.05)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Collect Radioactive
task.spawn(function()
    while scriptRunning do
        if autoCollectRadioactive then
            pcall(function()
                local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                local folder = workspace:FindFirstChild("RadioactiveEventParts")
                if not hrp or not folder then return end

                for _, coin in ipairs(folder:GetChildren()) do
                    if coin.Name == "Radioactive Coin" or coin.Name:lower():find("coin") or coin.Name == "coins" then
                        -- prefer the 'hitbox' part
                        local hitboxPart = coin:FindFirstChild("hitbox") or coin:FindFirstChild("Hitbox")
                        if hitboxPart and hitboxPart:IsA("BasePart") then
                            pcall(function()
                                firetouchinterest(hrp, hitboxPart, 0)
                                firetouchinterest(hrp, hitboxPart, 1)
                            end)
                            task.wait(0.01)
                        else
                            -- fallback: find any BasePart descendant (or TouchInterest owner)
                            for _, d in ipairs(coin:GetDescendants()) do
                                if d:IsA("BasePart") and (d:FindFirstChild("TouchInterest") or d.Name:lower():find("hitbox") or d.Name:lower():find("coin")) then
                                    pcall(function()
                                        firetouchinterest(hrp, d, 0)
                                        firetouchinterest(hrp, d, 1)
                                    end)
                                    task.wait(0.01)
                                    break
                                end
                            end
                        end
                    end
                end
            end)
            task.wait(0.05)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Collect Gold Bar (Money Event) — specifically touch GoldBar.Main (or its BasePart)
task.spawn(function()
    while scriptRunning do
        if autoCollectGoldBar then
            pcall(function()
                local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                local folder = workspace:FindFirstChild("MoneyEventParts")
                if not hrp or not folder then return end
                for _, gb in ipairs(folder:GetChildren()) do
                    if gb.Name == "GoldBar" or gb.Name:lower():find("gold") then
                        -- prefer the 'Main' part (some maps place the collectible under GoldBar.Main)
                        local mainPart = gb:FindFirstChild("Main")
                        if mainPart and mainPart:IsA("BasePart") then
                            pcall(function()
                                firetouchinterest(hrp, mainPart, 0)
                                firetouchinterest(hrp, mainPart, 1)
                            end)
                            task.wait(0.01)
                        else
                            -- fallback: find any BasePart descendant (or TouchInterest owner)
                            for _, d in ipairs(gb:GetDescendants()) do
                                if d:IsA("BasePart") and (d:FindFirstChild("TouchInterest") or d.Name:lower():find("main") or d.Name:lower():find("gold")) then
                                    pcall(function()
                                        firetouchinterest(hrp, d, 0)
                                        firetouchinterest(hrp, d, 1)
                                    end)
                                    task.wait(0.01)
                                    break
                                end
                            end
                        end
                    end
                end
            end)
            task.wait(0.05)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Collect Game Console (Arcade Event)
task.spawn(function()
    while scriptRunning do
        if autoCollectGameConsole then
            pcall(function()
                local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                local folder = workspace:FindFirstChild("ArcadeEventConsoles")
                if not hrp or not folder then return end

                for _, gc in ipairs(folder:GetChildren()) do
                    if gc.Name == "Game Console" or gc.Name:lower():find("console") then
                        -- prefer the 'Game Console' part
                        local consolePart = gc:FindFirstChild("Game Console")
                        if consolePart and consolePart:IsA("BasePart") then
                            pcall(function()
                                firetouchinterest(hrp, consolePart, 0)
                                firetouchinterest(hrp, consolePart, 1)
                            end)
                            task.wait(0.01)
                        else
                            -- fallback: find any BasePart descendant (or TouchInterest owner)
                            for _, d in ipairs(gc:GetDescendants()) do
                                if d:IsA("BasePart") and (d:FindFirstChild("TouchInterest") or d.Name:lower():find("console") or d.Name:lower():find("game")) then
                                    pcall(function()
                                        firetouchinterest(hrp, d, 0)
                                        firetouchinterest(hrp, d, 1)
                                    end)
                                    task.wait(0.01)
                                    break
                                end
                            end
                        end
                    end
                end
            end)
            task.wait(0.05)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Collect Arcade Ticket
task.spawn(function()
    while scriptRunning do
        if autoCollectArcadeTicket then
            pcall(function()
                local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                local folder = workspace:FindFirstChild("ArcadeEventTickets")
                if not hrp or not folder then return end

                for _, tk in ipairs(folder:GetChildren()) do
                    if tk.Name == "Ticket" or tk.Name:lower():find("ticket") then
                        -- prefer the 'Ticket' part
                        local ticketPart = tk:FindFirstChild("Ticket") or tk:FindFirstChild("ticket")
                        if ticketPart and ticketPart:IsA("BasePart") then
                            pcall(function()
                                firetouchinterest(hrp, ticketPart, 0)
                                firetouchinterest(hrp, ticketPart, 1)
                            end)
                            task.wait(0.01)
                        else
                            -- fallback: find any BasePart descendant (or TouchInterest owner)
                            for _, d in ipairs(tk:GetDescendants()) do
                                if d:IsA("BasePart") and (d:FindFirstChild("TouchInterest") or d.Name:lower():find("ticket")) then
                                    pcall(function()
                                        firetouchinterest(hrp, d, 0)
                                        firetouchinterest(hrp, d, 1)
                                    end)
                                    task.wait(0.01)
                                    break
                                end
                            end
                        end
                    end
                end
            end)
            task.wait(0.05)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Spin Arcade Wheel Loop
task.spawn(function()
    while scriptRunning do
        if autoSpinArcadeWheel then
            pcall(function()
                local args = { "Arcade", false }
                game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
                    "RF/WheelSpin.Roll"):InvokeServer(unpack(args))
            end)
            local delayValue = tonumber(savedSettings.spinDelay) or 0.5
            if delayValue <= 0 then delayValue = 0.5 end
            task.wait(delayValue)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Spin Valentines Wheel Loop
task.spawn(function()
    while scriptRunning do
        if autoSpinValentinesWheel then
            pcall(function()
                local args = { "Valentines", false }
                game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
                    "RF/WheelSpin.Roll"):InvokeServer(unpack(args))
            end)
            local delayValue = tonumber(savedSettings.spinDelay) or 0.5
            if delayValue <= 0 then delayValue = 0.5 end
            task.wait(delayValue)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Collect Candy (Valentines Event)
task.spawn(function()
    while scriptRunning do
        if autoCollectCandy then
            pcall(function()
                local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                local folder = workspace:FindFirstChild("CandyEventParts")
                if not hrp or not folder then return end

                for _, candy in ipairs(folder:GetChildren()) do
                    if candy.Name:lower():find("candy") then
                        -- Look for HeartCandy1 part
                        local heartPart = candy:FindFirstChild("HeartCandy1")
                        if heartPart and heartPart:IsA("BasePart") then
                            pcall(function()
                                firetouchinterest(hrp, heartPart, 0)
                                firetouchinterest(hrp, heartPart, 1)
                            end)
                            task.wait(0.01)
                        else
                            -- fallback: find any BasePart with TouchInterest
                            for _, d in ipairs(candy:GetDescendants()) do
                                if d:IsA("BasePart") and d:FindFirstChild("TouchInterest") then
                                    pcall(function()
                                        firetouchinterest(hrp, d, 0)
                                        firetouchinterest(hrp, d, 1)
                                    end)
                                    task.wait(0.01)
                                    break
                                end
                            end
                        end
                    end
                end
            end)
            task.wait(0.05)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Collect Valentines Coin (Love Token)
task.spawn(function()
    while scriptRunning do
        if autoCollectValentinesCoin then
            pcall(function()
                local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                local folder = workspace:FindFirstChild("ValentinesCoinParts")
                if not hrp or not folder then return end

                for _, coin in ipairs(folder:GetChildren()) do
                    if coin.Name:lower():find("valentine") or coin.Name:lower():find("coin") then
                        -- Look for lovetoken part
                        local tokenPart = coin:FindFirstChild("lovetoken")
                        if tokenPart and tokenPart:IsA("BasePart") then
                            pcall(function()
                                firetouchinterest(hrp, tokenPart, 0)
                                firetouchinterest(hrp, tokenPart, 1)
                            end)
                            task.wait(0.01)
                        else
                            -- fallback: find any BasePart with TouchInterest
                            for _, d in ipairs(coin:GetDescendants()) do
                                if d:IsA("BasePart") and d:FindFirstChild("TouchInterest") then
                                    pcall(function()
                                        firetouchinterest(hrp, d, 0)
                                        firetouchinterest(hrp, d, 1)
                                    end)
                                    task.wait(0.01)
                                    break
                                end
                            end
                        end
                    end
                end
            end)
            task.wait(0.05)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Spin Money Wheel Loop
task.spawn(function()
    while scriptRunning do
        if autoSpinMoneyWheel then
            pcall(function()
                local args = { [1] = "Money", [2] = false }
                local ok, remote = pcall(function()
                    return game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net")
                        :FindFirstChild("RF/WheelSpin.Roll")
                end)
                if ok and remote then
                    pcall(function() remote:InvokeServer(unpack(args)) end)
                end
            end)
            local delayValue = tonumber(savedSettings.spinDelay) or 0.5
            if delayValue <= 0 then delayValue = 0.5 end
            task.wait(delayValue)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Spin UFO Wheel Loop
task.spawn(function()
    while scriptRunning do
        if autoSpinUFO then
            pcall(function()
                local success, args = pcall(function()
                    return { "UFO", false }
                end)
                if success and args then
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
                            "RF/WheelSpin.Roll"):InvokeServer(unpack(args))
                    end)
                end
            end)
            local delayValue = tonumber(savedSettings.spinDelay) or 0.5
            if delayValue <= 0 then delayValue = 0.5 end
            task.wait(delayValue)
        else
            task.wait(0.5)
        end
    end
end)

-- Auto Complete Radioactive Obby Loop (fires 3x then waits 15 minutes)
task.spawn(function()
    while scriptRunning do
        if autoObby then
            -- First, wait until RadioactiveMap_SharedInstances appears
            local radioactiveMap = nil
            while autoObby and not radioactiveMap do
                local root = findRadioactiveRoot()
                if root then
                    radioactiveMap = root
                else
                    task.wait(2) -- Check every 2 seconds
                end
            end

            -- If toggle was disabled while waiting, skip this cycle
            if not autoObby then
                task.wait(1)
            else
                -- Found the radioactive map
                WindUI:Notify({
                    Title = "Radioactive Obby",
                    Content = "Radioactive Event found! Starting...",
                    Icon =
                    "check",
                    Duration = 2
                })

                -- Run the obby completion sequence 2 times
                for cycleCount = 1, 2 do
                    if not autoObby then break end

                    local completed = false
                    pcall(function()
                        local rootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                        if not rootPart then return end

                        -- Re-check radioactiveMap exists
                        local rms = workspace:FindFirstChild("RadioactiveMap_SharedInstances")
                        if not rms then return end

                        -- Step 1: Touch the ObbyEnd TouchInterest (prevents death if touched before teleport)
                        local obbyEnd = rms:FindFirstChild("ObbyEnd")
                        if obbyEnd then
                            -- find a BasePart to touch that contains a TouchInterest/TouchTransmitter
                            local touchPart = nil
                            if obbyEnd:IsA("BasePart") then
                                touchPart = obbyEnd
                            else
                                for _, d in ipairs(obbyEnd:GetDescendants()) do
                                    if d:IsA("BasePart") and (d:FindFirstChild("TouchInterest") or d:FindFirstChildOfClass("TouchTransmitter")) then
                                        touchPart = d
                                        break
                                    end
                                end
                            end

                            if touchPart then
                                pcall(function()
                                    firetouchinterest(rootPart, touchPart, 0)
                                    task.wait(0.1)
                                    firetouchinterest(rootPart, touchPart, 1)
                                end)

                                -- wait 2s before teleporting to reduce chance of dying
                                task.wait(2)

                                local targetPos = touchPart.Position or (obbyEnd:IsA("BasePart") and obbyEnd.Position) or
                                    (obbyEnd:IsA("Model") and obbyEnd:GetPivot().Position)
                                if targetPos then
                                    rootPart.CFrame = CFrame.new(targetPos + Vector3.new(0, 5, 0))
                                    task.wait(0.3)
                                end
                            end
                        end

                        completed = true
                    end)

                    -- Notify after each cycle
                    if completed then
                        WindUI:Notify({
                            Title = "Radioactive Obby",
                            Content = "Cycle " .. cycleCount .. "/2 completed",
                            Icon =
                            "check",
                            Duration = 2
                        })
                    end

                    if cycleCount < 2 then
                        task.wait(2) -- Small delay between cycles
                    end
                end

                -- All 2 cycles complete, wait 15 minutes
                WindUI:Notify({ Title = "Radioactive Obby", Content = "2 cycles done", Icon = "clock", Duration = 3 })
                task.wait(900) -- 15 minutes = 900 seconds
            end
        else
            task.wait(1)
        end
    end
end)

-- Auto Complete Money Obby Loop (fires 3x then waits 15 minutes)
task.spawn(function()
    while scriptRunning do
        if autoCompleteMoneyObby then
            -- First, wait until MoneyMap_SharedInstances appears
            local moneyMap = nil
            while autoCompleteMoneyObby and not moneyMap do
                moneyMap = workspace:FindFirstChild("MoneyMap_SharedInstances")
                if not moneyMap then
                    task.wait(2) -- Check every 2 seconds
                end
            end

            -- If toggle was disabled while waiting, skip this cycle
            if not autoCompleteMoneyObby then
                task.wait(1)
            else
                -- Found the money map
                WindUI:Notify({ Title = "Money Obby", Content = "Money Event found! Starting...", Icon = "check", Duration = 2 })

                -- Run the obby completion sequence 3 times
                for cycleCount = 1, 3 do
                    if not autoCompleteMoneyObby then break end

                    local completed = false
                    pcall(function()
                        local rootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                        if not rootPart then return end

                        -- Re-check moneyMap exists
                        moneyMap = workspace:FindFirstChild("MoneyMap_SharedInstances")
                        if not moneyMap then return end

                        -- Complete Obby 1
                        local obby1End = moneyMap:FindFirstChild("MoneyObby1End")
                        if obby1End and obby1End:FindFirstChild("TouchInterest") then
                            pcall(function()
                                firetouchinterest(rootPart, obby1End, 0)
                                task.wait(0.1)
                                firetouchinterest(rootPart, obby1End, 1)
                            end)
                            task.wait(1)
                        end

                        -- Touch Checkpoint 3
                        local checkpoint3 = moneyMap:FindFirstChild("MoneyCheckpoint3")
                        if checkpoint3 and checkpoint3:FindFirstChild("TouchInterest") then
                            pcall(function()
                                firetouchinterest(rootPart, checkpoint3, 0)
                                task.wait(0.1)
                                firetouchinterest(rootPart, checkpoint3, 1)
                            end)
                            task.wait(1)
                        end

                        -- Complete Obby 2
                        local obby2End = moneyMap:FindFirstChild("MoneyObby2End")
                        if obby2End and obby2End:FindFirstChild("TouchInterest") then
                            pcall(function()
                                firetouchinterest(rootPart, obby2End, 0)
                                task.wait(0.1)
                                firetouchinterest(rootPart, obby2End, 1)
                            end)
                            task.wait(1)
                        end

                        -- Complete Obby 3
                        local obby3End = moneyMap:FindFirstChild("MoneyObby3End")
                        if obby3End and obby3End:FindFirstChild("TouchInterest") then
                            pcall(function()
                                firetouchinterest(rootPart, obby3End, 0)
                                task.wait(0.1)
                                firetouchinterest(rootPart, obby3End, 1)
                            end)
                        end

                        completed = true
                    end)

                    -- Notify after each cycle
                    if completed then
                        WindUI:Notify({
                            Title = "Money Obby",
                            Content = "Cycle " .. cycleCount .. "/3 completed",
                            Icon =
                            "check",
                            Duration = 2
                        })
                    end

                    if cycleCount < 3 then
                        task.wait(2) -- Small delay between cycles
                    end
                end

                -- All 3 cycles complete
                WindUI:Notify({ Title = "Money Obby", Content = "3 cycles done", Icon = "clock", Duration = 3 })

                -- If user enabled auto-rejoin, rejoin now; otherwise keep the original 15-minute cooldown
                if autoRejoinAfterMoneyObby then
                    pcall(function()
                        WindUI:Notify({
                            Title = "Money Obby",
                            Content = "Auto-rejoin enabled — rejoining...",
                            Icon =
                            "info",
                            Duration = 2
                        })
                        task.wait(0.6)
                        game:GetService("TeleportService"):Teleport(game.PlaceId, player)
                    end)
                    return
                else
                    task.wait(900) -- 15 minutes = 900 seconds
                end
            end
        else
            task.wait(1)
        end
    end
end)

-- Auto Upgrade Base Loop
task.spawn(function()
    while scriptRunning do
        if autoUpgradeBase then
            pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
                    "RE/Plot.UpgradeBase"):FireServer()
            end)
            task.wait(0.5)
        else
            task.wait(1)
        end
    end
end)

-- Auto Upgrade Carry Loop
task.spawn(function()
    while scriptRunning do
        if autoUpgradeCarry then
            pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("UpgradeCarry")
                    :InvokeServer()
            end)
            task.wait(0.5)
        else
            task.wait(1)
        end
    end
end)

-- Auto Upgrade Jump Loop
task.spawn(function()
    while scriptRunning do
        if autoUpgradeJump then
            pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
                    "RF/UpgradeJump"):InvokeServer()
            end)
            task.wait(0.5)
        else
            task.wait(1)
        end
    end
end)

-- Auto Upgrade Speed Loop
task.spawn(function()
    while scriptRunning do
        if autoUpgradeSpeed then
            pcall(function()
                local args = { upgradeSpeedAmount }
                game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("UpgradeSpeed")
                    :InvokeServer(unpack(args))
            end)
            task.wait(0.5)
        else
            task.wait(1)
        end
    end
end)

-- Auto Rebirth Loop
task.spawn(function()
    while scriptRunning do
        if autoRebirth then
            pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("Rebirth")
                    :InvokeServer()
            end)
            task.wait(1)
        else
            task.wait(1)
        end
    end
end)

-- Auto Sell by Rarity Loop
task.spawn(function()
    while scriptRunning do
        if autoSellByRarity and #sellRarities > 0 then
            pcall(function()
                local backpack = player:FindFirstChild("Backpack")
                local character = player.Character
                if not backpack or not character then return end

                local humanoid = character:FindFirstChild("Humanoid")
                if not humanoid then return end

                -- Build list of brainrots to sell from selected rarities (using cached data)
                local brainrotsToSell = {}
                local data = loadBrainrotsData()
                
                if data and data.Chances then
                    for rarity, brainrots in pairs(data.Chances) do
                        -- Check if this rarity is in the sellRarities list
                        for _, targetRarity in ipairs(sellRarities) do
                            if rarity == targetRarity then
                                -- Add all brainrots from this rarity to the sell list
                                for brainrotName, _ in pairs(brainrots) do
                                    brainrotsToSell[brainrotName] = true
                                end
                                break
                            end
                        end
                    end
                end

                for _, tool in ipairs(backpack:GetChildren()) do
                    if not autoSellByRarity then break end

                    if tool:IsA("Tool") then
                        local brainrotName = tool:GetAttribute("BrainrotName")
                        if brainrotName and brainrotsToSell[brainrotName] then
                            humanoid:EquipTool(tool)
                            task.wait(0.15)


                            pcall(function()
                                game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions")
                                    :WaitForChild("SellTool"):InvokeServer()
                            end)
                            task.wait(0.2)
                        end
                    end
                end
            end)
            task.wait(1)
        else
            task.wait(1)
        end
    end
end)

-- Auto Sell by Name Loop
task.spawn(function()
    while scriptRunning do
        if autoSellByName and #sellBrainrotNames > 0 then
            pcall(function()
                local backpack = player:FindFirstChild("Backpack")
                local character = player.Character
                if not backpack or not character then return end

                local humanoid = character:FindFirstChild("Humanoid")
                if not humanoid then return end

                -- Build set of brainrot names to sell
                local namesToSell = {}
                for _, name in ipairs(sellBrainrotNames) do
                    namesToSell[name] = true
                end

                for _, tool in ipairs(backpack:GetChildren()) do
                    if not autoSellByName then break end

                    if tool:IsA("Tool") then
                        local brainrotName = tool:GetAttribute("BrainrotName")
                        if brainrotName and namesToSell[brainrotName] then
                            humanoid:EquipTool(tool)
                            task.wait(0.15)
                            pcall(function()
                                game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions")
                                    :WaitForChild("SellTool"):InvokeServer()
                            end)
                            task.wait(0.2)
                        end
                    end
                end
            end)
            task.wait(1)
        else
            task.wait(1)
        end
    end
end)

-- Function to scan player's base for brainrot slots
local function scanBaseBrainrots()
    local foundBrainrots = {}
    pcall(function()
        -- Use findMyBase() to get the player's base
        local myBase = findMyBase()
        if not myBase then return end

        -- Scan slots 1-40 for brainrots
        for i = 1, 40 do
            local slotName = "slot " .. i .. " brainrot"
            local slot = myBase:FindFirstChild(slotName)
            if slot then
                local brainrotName = slot:GetAttribute("BrainrotName")
                local level = slot:GetAttribute("Level")

                -- Only include slots with non-empty BrainrotName
                if brainrotName and brainrotName ~= "" and level then
                    local label = "Level " .. level .. " " .. brainrotName .. " (Slot " .. i .. ")"
                    table.insert(foundBrainrots, {
                        label = label,
                        baseName = myBase.Name,
                        slotNum = tostring(i)
                    })
                end
            end
        end
    end)
    return foundBrainrots
end

-- Auto Upgrade Brainrot Loop
task.spawn(function()
    while scriptRunning do
        if autoUpgradeBrainrot and #upgradeBrainrotTargets > 0 then
            pcall(function()
                for _, entry in ipairs(upgradeBrainrotTargets) do
                    if not autoUpgradeBrainrot then break end

                    -- Find the matching slot data
                    for _, slotData in ipairs(brainrotSlotData) do
                        if slotData.label == entry then
                            local args = {
                                "Upgrade Brainrot",
                                slotData.baseName,
                                slotData.slotNum
                            }
                            pcall(function()
                                game:GetService("ReplicatedStorage"):WaitForChild("Packages")
                                    :WaitForChild("Net"):WaitForChild("RF/Plot.PlotAction"):InvokeServer(unpack(args))
                            end)
                            task.wait(0.1)
                            break
                        end
                    end
                end
            end)
            task.wait(1)
        else
            task.wait(1)
        end
    end
end)

-- Anti-AFK (Always Enabled - Prevents 20 min AFK kick)
local vu = game:GetService("VirtualUser")
player.Idled:Connect(function()
    vu:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
    task.wait(1)
    vu:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
end)

-- Auto Reconnect (Always Enabled)
pcall(function()
    game.CoreGui.RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
        if child.Name == 'ErrorPrompt' and child:FindFirstChild('MessageArea') and child.MessageArea:FindFirstChild("ErrorFrame") then
            game:GetService("TeleportService"):Teleport(game.PlaceId, player)
        end
    end)
end)

-- Unlock Zoom handlers
local function enableUnlockZoom()
    if unlockZoomEnabled then return end
    unlockZoomEnabled = true
    -- store previous values if present
    pcall(function()
        prevCameraMin = player.CameraMinZoomDistance
        prevCameraMax = player.CameraMaxZoomDistance
    end)

    local applied = false
    -- Try to set on Player
    pcall(function()
        player.CameraMinZoomDistance = 0.5
        player.CameraMaxZoomDistance = 500
        applied = true
    end)

    -- Also try CurrentCamera in case of alternate API
    pcall(function()
        local cam = workspace and workspace.CurrentCamera
        if cam then
            pcall(function()
                cam.CameraMinZoomDistance = 0.5
                cam.CameraMaxZoomDistance = 500
                applied = true
            end)
        end
    end)

    if applied then
        WindUI:Notify({ Title = "Main", Content = "Zoom limits unlocked", Icon = "check", Duration = 3 })
    else
        WindUI:Notify({ Title = "Main", Content = "Failed to change zoom limits", Icon = "alert-triangle", Duration = 4 })
    end
end

local function disableUnlockZoom()
    if not unlockZoomEnabled then return end
    unlockZoomEnabled = false
    local restored = false
    pcall(function()
        if prevCameraMin then
            player.CameraMinZoomDistance = prevCameraMin; restored = true
        end
        if prevCameraMax then
            player.CameraMaxZoomDistance = prevCameraMax; restored = true
        end
    end)
    pcall(function()
        local cam = workspace and workspace.CurrentCamera
        if cam then
            pcall(function()
                if prevCameraMin then cam.CameraMinZoomDistance = prevCameraMin end
                if prevCameraMax then cam.CameraMaxZoomDistance = prevCameraMax end
                restored = true
            end)
        end
    end)

    if restored then
        WindUI:Notify({ Title = "Main", Content = "Zoom limits restored", Icon = "check", Duration = 3 })
    else
        WindUI:Notify({ Title = "Main", Content = "Zoom restore attempted", Icon = "check", Duration = 3 })
    end
end

-- ================= TSUNAMI TRACKER =================
-- Creates a small ScreenGui that shows distance & color-coded status for nearby tsunamis
local RunService = game:GetService("RunService")
local tsunamiGui = nil
local tsunamiBox = nil
local tsunamiText = nil
local tsunamiHeartbeatConn = nil
local tsunamiEnabled = false

local function getTsunamiDistance()
    local character = player.Character
    if not character then return math.huge end
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return math.huge end

    local closest = math.huge
    local activeTsunamis = workspace:FindFirstChild("ActiveTsunamis")
    if activeTsunamis then
        for i = 1, 6 do
            local wave = activeTsunamis:FindFirstChild("Wave" .. i)
            if wave then
                local hitbox = wave:FindFirstChild("Hitbox")
                if hitbox and hitbox:IsA("BasePart") then
                    local dist = (hitbox.Position - root.Position).Magnitude
                    if dist < closest then
                        closest = dist
                    end
                end
            end
        end
    end

    if closest == math.huge then
        for _, obj in pairs(workspace:GetChildren()) do
            if obj:IsA("Model") then
                if obj.Name:lower():find("tsunami") or obj.Name:lower():find("wave") then
                    for _, part in pairs(obj:GetDescendants()) do
                        if part:IsA("BasePart") then
                            local dist = (part.Position - root.Position).Magnitude
                            if dist < closest then
                                closest = dist
                            end
                        end
                    end
                end
            end
        end
    end

    return closest
end

local function createTsunamiGui()
    if tsunamiGui then return end
    tsunamiGui = Instance.new("ScreenGui")
    tsunamiGui.Name = "XuanTsunamiTracker"
    tsunamiGui.ResetOnSpawn = false
    tsunamiGui.Parent = player:WaitForChild("PlayerGui")

    tsunamiBox = Instance.new("Frame")
    tsunamiBox.Name = "TsunamiBox"
    tsunamiBox.Size = UDim2.fromOffset(220, 26)
    tsunamiBox.Position = UDim2.fromOffset(12, 12)
    tsunamiBox.BackgroundColor3 = Color3.fromRGB(30, 34, 45)
    tsunamiBox.BorderSizePixel = 0
    tsunamiBox.Parent = tsunamiGui

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = tsunamiBox

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(80, 80, 100)
    stroke.LineJoinMode = Enum.LineJoinMode.Round
    stroke.Parent = tsunamiBox

    tsunamiText = Instance.new("TextLabel")
    tsunamiText.Name = "TsunamiText"
    tsunamiText.Size = UDim2.new(1, -10, 1, -4)
    tsunamiText.Position = UDim2.fromOffset(8, 1)
    tsunamiText.BackgroundTransparency = 1
    tsunamiText.TextColor3 = Color3.fromRGB(255, 255, 255)
    tsunamiText.Text = "Tsunami: Safe (>1500m)"
    tsunamiText.Font = Enum.Font.Gotham
    tsunamiText.TextSize = 13
    tsunamiText.TextXAlignment = Enum.TextXAlignment.Left
    tsunamiText.TextYAlignment = Enum.TextYAlignment.Center
    tsunamiText.Parent = tsunamiBox

    tsunamiHeartbeatConn = RunService.Heartbeat:Connect(function()
        local dist = getTsunamiDistance()
        if dist < 1500 then
            if dist <= 500 then
                tsunamiBox.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
                tsunamiText.TextColor3 = Color3.new(1, 1, 1)
                tsunamiText.Text = "⚠️ Tsunami: " .. math.floor(dist) .. "m (DANGER)"
            elseif dist <= 1000 then
                tsunamiBox.BackgroundColor3 = Color3.fromRGB(255, 150, 50)
                tsunamiText.TextColor3 = Color3.new(0, 0, 0)
                tsunamiText.Text = "Tsunami: " .. math.floor(dist) .. "m (WARNING)"
            else
                tsunamiBox.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
                tsunamiText.TextColor3 = Color3.new(0, 0, 0)
                tsunamiText.Text = "Tsunami: " .. math.floor(dist) .. "m (SAFE)"
            end
        else
            tsunamiBox.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
            tsunamiText.TextColor3 = Color3.new(1, 1, 1)
            tsunamiText.Text = "Tsunami: Safe (>1500m)"
        end
    end)
end

local function destroyTsunamiGui()
    if tsunamiHeartbeatConn then
        tsunamiHeartbeatConn:Disconnect()
        tsunamiHeartbeatConn = nil
    end
    if tsunamiGui then
        tsunamiGui:Destroy()
        tsunamiGui = nil
        tsunamiBox = nil
        tsunamiText = nil
    end
end

local function enableTsunamiTracker()
    if tsunamiEnabled then return end
    tsunamiEnabled = true
    createTsunamiGui()
    WindUI:Notify({
        Title = "Tsunami",
        Content = "Tsunami tracker enabled",
        Icon = "check",
        Duration = 3,
    })
end

local function disableTsunamiTracker()
    if not tsunamiEnabled then return end
    tsunamiEnabled = false
    destroyTsunamiGui()
    WindUI:Notify({
        Title = "Tsunami",
        Content = "Tsunami tracker disabled",
        Icon = "check",
        Duration = 3,
    })
end

-- Add a section + toggle in the Tsunami tab
local TsunamiSection = TsunamiTab:Section({ Title = "Tsunami Tracker", Opened = true, })
TsunamiSection:Toggle({
    Title = "Tsunami Tracker",
    Desc = "Toggle tsunami tracker display",
    Icon = "check",
    Value = savedSettings.autoTsunamiTracker,
    Callback = function(state)
        if state then
            enableTsunamiTracker()
        else
            disableTsunamiTracker()
        end
        savedSettings.autoTsunamiTracker = state
        saveSettings(savedSettings)
    end
})

local function findGapsFolder()
    -- return the first existing 'Gaps' folder from known map locations
    local candidates = {
        (workspace:FindFirstChild("DefaultMap") and workspace.DefaultMap:FindFirstChild("Gaps")),
        (workspace:FindFirstChild("MarsMap") and workspace.MarsMap:FindFirstChild("Gaps")),
        (workspace:FindFirstChild("MoneyMap") and workspace.MoneyMap.DefaultStudioMap:FindFirstChild("Gaps")),
        (workspace:FindFirstChild("RadioactiveMap") and workspace.RadioactiveMap:FindFirstChild("Gaps")),
        (workspace:FindFirstChild("Misc") and workspace.Misc:FindFirstChild("Gaps")),
    }
    for _, f in ipairs(candidates) do
        if f then return f end
    end
    return nil
end

-- TP Next Gap button removed by user request. Use `XuanHub_TPNextGap()` from console or rebind later.

-- Teleport to previous gap (behind player) — single-step SmartMove (uses same ordering/safety as Smart Teleport)
-- TP Previous Gap button removed by user request. Use `XuanHub_TPPrevGap()` from console or rebind later.

-- Teleport to your base
TsunamiSection:Button({
    Title = "Teleport to Base",
    Desc = "Teleport to your base",
    Locked = false,
    Callback = function()
        teleportToBaseSmooth()
    end
})

-- Smart-tour helpers (used by the Auto Tour toggles)
local TweenService = game:GetService("TweenService")
_G.BaseTweenSpeed = 0.15
_G.AutoTourActive = false
_G.ReverseTourActive = false
_G.PostWaveBuffer = 0.05



-- Generic collector: returns array of { idx = number, name = string, part = BasePart, inst = Instance }
local function collectGapEntries(folder)
    if not folder then return {} end
    local entries = {}
    for _, child in ipairs(folder:GetChildren()) do
        if child then
            -- attempt to find a usable BasePart for positioning
            -- Prioritize "Mud" part if it exists
            local part = nil

            -- First, try to find Mud part
            local mudPart = child:FindFirstChild("Mud")
            if mudPart and mudPart:IsA("BasePart") then
                part = mudPart
            else
                -- Fall back to original logic
                part = (child:IsA("BasePart") and child) or
                    (child:IsA("Model") and (child.PrimaryPart or getModelPart(child)))
                if not part then
                    for _, d in ipairs(child:GetDescendants()) do
                        if d:IsA("BasePart") then
                            part = d; break
                        end
                    end
                end
            end

            if part then
                local num = tonumber(child.Name:match("%d+"))
                table.insert(entries, { idxRaw = num, name = child.Name, part = part, inst = child })
            end
        end
    end

    if #entries == 0 then return entries end

    -- If any entries have numeric indices, sort by that; otherwise sort by X (left→right)
    local hasNumbers = false
    for _, e in ipairs(entries) do
        if e.idxRaw then
            hasNumbers = true; break
        end
    end
    if hasNumbers then
        table.sort(entries, function(a, b)
            return (a.idxRaw or 9999) < (b.idxRaw or 9999)
        end)
        for i, e in ipairs(entries) do e.idx = e.idxRaw or i end
    else
        table.sort(entries, function(a, b)
            return a.part.Position.X < b.part.Position.X
        end)
        for i, e in ipairs(entries) do e.idx = i end
    end

    return entries
end

local function GetNearestGapIndex()
    local gaps = findGapsFolder()
    local hrp = game.Players.LocalPlayer.Character and
        game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not gaps or not hrp then return 1 end

    local entries = collectGapEntries(gaps)
    if #entries == 0 then return 1 end

    local nearestIndex, minDistance = entries[1].idx, math.huge
    for _, e in ipairs(entries) do
        local ok, pos = pcall(function()
            if e.inst and e.inst.GetModelCFrame then
                return e.inst:GetModelCFrame().Position
            elseif e.part then
                return e.part.Position
            end
        end)
        if ok and pos then
            local dist = (hrp.Position - pos).Magnitude
            if dist < minDistance then
                minDistance, nearestIndex = dist, e.idx
            end
        end
    end
    return nearestIndex
end

local function IsPathClear(targetPos)
    local tsunamiFolder = workspace:FindFirstChild("ActiveTsunamis")
    if not tsunamiFolder then return true end
    local hrp = game.Players.LocalPlayer.Character and
        game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return true end
    local padding = 45
    local currentPos = hrp.Position
    local minX, maxX = math.min(currentPos.X, targetPos.X) - padding, math.max(currentPos.X, targetPos.X) + padding
    local minZ, maxZ = math.min(currentPos.Z, targetPos.Z) - padding, math.max(currentPos.Z, targetPos.Z) + padding
    for _, model in pairs(tsunamiFolder:GetChildren()) do
        for _, part in pairs(model:GetChildren()) do
            if part:IsA("BasePart") and string.find(string.lower(part.Name), "wave") then
                local wPos = part.Position
                if (wPos.X >= minX and wPos.X <= maxX) and (wPos.Z >= minZ and wPos.Z <= maxZ) then
                    return false
                end
            end
        end
    end
    return true
end

local function SmartMove(targetPos, areaName)
    local char = game.Players.LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if hrp then
        -- Enable fly mode for safe teleportation
        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
        bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        bodyVelocity.Parent = hrp

        -- Enable noclip
        local noclipConn
        noclipConn = RunService.Stepped:Connect(function()
            if char then
                for _, part in pairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)

        local finalSpeed = _G.BaseTweenSpeed
        local areaNum = tonumber(string.match(areaName, "%d+"))
        if areaNum and areaNum >= 6 then
            finalSpeed = _G.BaseTweenSpeed * 5.0
        end
        local info = TweenInfo.new(finalSpeed, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(hrp, info, { CFrame = CFrame.new(targetPos) })
        tween:Play()
        tween.Completed:Wait()

        -- Disable fly mode after teleport
        if bodyVelocity then
            bodyVelocity:Destroy()
        end

        if noclipConn then
            noclipConn:Disconnect()
        end

        -- Restore collision
        if char then
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
end

-- Death detection for smart teleport reset
player.CharacterAdded:Connect(function(char)
    local humanoid = char:WaitForChild("Humanoid")
    humanoid.Died:Connect(function()
        if _G.AutoTourActive then
            -- Teleport to first gap when player dies
            task.wait(2) -- Wait for respawn
            local newChar = player.Character
            if newChar then
                local gapsFolder = findGapsFolder()
                if gapsFolder then
                    local entries = collectGapEntries(gapsFolder)
                    if #entries > 0 then
                        local firstGap = entries[1]
                        local ok, pos = pcall(function()
                            if firstGap.inst and firstGap.inst.GetModelCFrame then
                                return firstGap.inst:GetModelCFrame().Position
                            elseif firstGap.part then
                                return firstGap.part.Position
                            end
                        end)
                        if ok and pos then
                            local targetPos = pos + Vector3.new(0, 3, 0)
                            local root = newChar:FindFirstChild("HumanoidRootPart")
                            if root then
                                root.CFrame = CFrame.new(targetPos)
                                WindUI:Notify({ Title = "Teleport", Content = "Respawned at Gap 1 - continuing teleport", Icon =
                                "info", Duration = 3 })
                            end
                        end
                    end
                end
            end
        end
        if _G.ReverseTourActive then
            _G.ReverseTourActive = false
            WindUI:Notify({ Title = "Teleport", Content = "Smart teleport stopped (player died)", Icon = "alert-triangle", Duration = 3 })
        end
    end)
end)

-- Also set up for current character if it exists
if player.Character then
    local humanoid = player.Character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.Died:Connect(function()
            if _G.AutoTourActive then
                -- Teleport to first gap when player dies
                task.wait(2) -- Wait for respawn
                local newChar = player.Character
                if newChar then
                    local gapsFolder = findGapsFolder()
                    if gapsFolder then
                        local entries = collectGapEntries(gapsFolder)
                        if #entries > 0 then
                            local firstGap = entries[1]
                            local ok, pos = pcall(function()
                                if firstGap.inst and firstGap.inst.GetModelCFrame then
                                    return firstGap.inst:GetModelCFrame().Position
                                elseif firstGap.part then
                                    return firstGap.part.Position
                                end
                            end)
                            if ok and pos then
                                local targetPos = pos + Vector3.new(0, 3, 0)
                                local root = newChar:FindFirstChild("HumanoidRootPart")
                                if root then
                                    root.CFrame = CFrame.new(targetPos)
                                    WindUI:Notify({ Title = "Teleport", Content =
                                    "Respawned at Gap 1 - continuing teleport", Icon = "info", Duration = 3 })
                                end
                            end
                        end
                    end
                end
            end
            if _G.ReverseTourActive then
                _G.ReverseTourActive = false
                WindUI:Notify({ Title = "Teleport", Content = "Smart teleport stopped (player died)", Icon =
                "alert-triangle", Duration = 3 })
            end
        end)
    end
end


-- Teleport to last gap (button)
TsunamiSection:Button({
    Title = "Smart Teleport to Last Gap",
    Desc = "Press to start teleport through gaps to the last gap",
    Locked = false,
    Callback = function()
        if _G.AutoTourActive then
            _G.AutoTourActive = false
            WindUI:Notify({ Title = "Teleport", Content = "Smart Teleport to Last Gap stopped", Icon = "check", Duration = 2 })
            return
        end

        _G.AutoTourActive = true
        _G.ReverseTourActive = false
        WindUI:Notify({ Title = "Teleport", Content = "Smart Teleport to Last Gap started", Icon = "check", Duration = 2 })
        task.spawn(function()
            local gapsFolder = findGapsFolder()
            if not gapsFolder then
                _G.AutoTourActive = false; return
            end

            local entries = collectGapEntries(gapsFolder)
            if #entries == 0 then
                _G.AutoTourActive = false; return
            end

            -- determine range and current index
            local maxIdx = entries[#entries].idx
            while _G.AutoTourActive do
                local currentPosIndex = GetNearestGapIndex()

                -- iterate only over entries with idx > currentPosIndex up to maxIdx
                for _, e in ipairs(entries) do
                    if not _G.AutoTourActive then break end
                    if e.idx > currentPosIndex and e.idx <= maxIdx then
                        local ok, pos = pcall(function()
                            if e.inst and e.inst.GetModelCFrame then
                                return e.inst:GetModelCFrame().Position
                            elseif e.part then
                                return e.part.Position
                            end
                        end)
                        if ok and pos then
                            local targetPos = (pos + Vector3.new(0, 3, 0))

                            -- notify once while waiting for the gap to become safe
                            local blockedNotified = false
                            while not IsPathClear(targetPos) and _G.AutoTourActive do
                                if not blockedNotified then
                                    pcall(function()
                                        WindUI:Notify({
                                            Title = "Teleport",
                                            Content = "Gap blocked — waiting: " ..
                                                tostring(e.name),
                                            Icon = "alert-triangle",
                                            Duration = 3
                                        })
                                    end)
                                    print("[XuanHub] SmartTeleport: waiting for gap to clear:", e.name)
                                    blockedNotified = true
                                end
                                task.wait(0.1)
                            end

                            if blockedNotified and _G.AutoTourActive then
                                pcall(function()
                                    WindUI:Notify({
                                        Title = "Teleport",
                                        Content = "Gap is now clear: " ..
                                            tostring(e.name),
                                        Icon = "check",
                                        Duration = 2
                                    })
                                end)
                                print("[XuanHub] SmartTeleport: gap cleared:", e.name)
                            end

                            SmartMove(targetPos, e.name)
                            task.wait(1.5)
                        end
                    end
                end

                -- stop if we've reached the last gap
                local nearest = GetNearestGapIndex()
                if nearest >= maxIdx then
                    _G.AutoTourActive = false
                    WindUI:Notify({ Title = "Teleport", Content = "Reached last gap — stopped", Icon = "check", Duration = 3 })
                    break
                end

                task.wait(2)
            end
        end)
    end,
})

-- Teleport to first gap (reverse) - button
TsunamiSection:Button({
    Title = "Smart Teleport to First Gap",
    Desc = "Press to Automatically teleport through gaps to the first gap",
    Locked = false,
    Callback = function()
        if _G.ReverseTourActive then
            _G.ReverseTourActive = false
            WindUI:Notify({ Title = "Teleport", Content = "Smart Teleport to First Gap stopped", Icon = "check", Duration = 2 })
            return
        end

        _G.ReverseTourActive = true
        _G.AutoTourActive = false
        WindUI:Notify({ Title = "Teleport", Content = "Smart Teleport to First Gap started", Icon = "check", Duration = 2 })
        task.spawn(function()
            local gapsFolder = findGapsFolder()
            if not gapsFolder then
                _G.ReverseTourActive = false; return
            end

            local entries = collectGapEntries(gapsFolder)
            if #entries == 0 then
                _G.ReverseTourActive = false; return
            end

            local minIdx = entries[1].idx
            while _G.ReverseTourActive do
                local currentPosIndex = GetNearestGapIndex()

                -- iterate entries with idx < currentPosIndex in descending order
                for i = #entries, 1, -1 do
                    if not _G.ReverseTourActive then break end
                    local e = entries[i]
                    if e.idx < currentPosIndex then
                        local ok, pos = pcall(function()
                            if e.inst and e.inst.GetModelCFrame then
                                return e.inst:GetModelCFrame().Position
                            elseif e.part then
                                return e.part.Position
                            end
                        end)
                        if ok and pos then
                            local targetPos = (pos + Vector3.new(0, 3, 0))

                            -- notify once while waiting for the gap to become safe
                            local blockedNotified = false
                            while not IsPathClear(targetPos) and _G.ReverseTourActive do
                                if not blockedNotified then
                                    pcall(function()
                                        WindUI:Notify({
                                            Title = "Teleport",
                                            Content = "Gap blocked — waiting: " ..
                                                tostring(e.name),
                                            Icon = "alert-triangle",
                                            Duration = 3
                                        })
                                    end)
                                    print("[XuanHub] SmartTeleport (reverse): waiting for gap to clear:", e.name)
                                    blockedNotified = true
                                end
                                task.wait(0.1)
                            end

                            if blockedNotified and _G.ReverseTourActive then
                                pcall(function()
                                    WindUI:Notify({
                                        Title = "Teleport",
                                        Content = "Gap is now clear: " ..
                                            tostring(e.name),
                                        Icon = "check",
                                        Duration = 2
                                    })
                                end)
                                print("[XuanHub] SmartTeleport (reverse): gap cleared:", e.name)
                            end

                            SmartMove(targetPos, e.name)
                            task.wait(1.5)
                        end
                    end
                end

                -- stop if we've reached the first gap
                local nearest = GetNearestGapIndex()
                if nearest <= minIdx then
                    _G.ReverseTourActive = false
                    WindUI:Notify({ Title = "Teleport", Content = "Reached first gap — stopped", Icon = "check", Duration = 3 })
                    break
                end

                task.wait(2)
            end
        end)
    end,
})

-- Teleport-by-Rarity (Tsunami)
-- Mapping (fixed): Common=Gap1 .. Celestial=Gap9
local RARITY_TO_GAP = { Common = 1, Uncommon = 2, Rare = 3, Epic = 4, Legendary = 5, Mythical = 6, Cosmic = 7, Secret = 8, Celestial = 9 }

-- Read-only UI element (shows configured target rarity)
-- NOTE: WindUI's Section may not expose a Tag method at runtime; place the tag in the Window header instead.


-- Dropdown to choose target rarity (persisted)
TsunamiSection:Dropdown({
    Title = "Teleport target rarity",
    Desc = "Which gap to stop at when using teleport-by-rarity",
    Values = { "Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical", "Cosmic", "Secret", "Celestial" },
    Value = tostring(savedSettings.autoTeleportByRarityTarget or "Common"),
    Multi = false,
    AllowNone = false,
    SearchBarEnabled = true,
    Callback = function(option)
        autoTeleportByRarityTarget = option
        savedSettings.autoTeleportByRarityTarget = option
        saveSettings(savedSettings)
        TeleportByRarityLabel:SetTitle("Target: " .. tostring(option))
    end,
})

-- Button: start a one-shot smart-teleport to the selected rarity's gap
TsunamiSection:Button({
    Title = "Teleport to Selected Rarity",
    Desc = "Smart-teleport forward until the selected rarity's gap",
    Callback = function()
        local r = autoTeleportByRarityTarget or savedSettings.autoTeleportByRarityTarget or "Common"
        local ok = pcall(function() return _G.XuanHub_TeleportToRarity and _G.XuanHub_TeleportToRarity(r) end)
        if ok and _G.XuanHub_TeleportToRarity then
            TeleportByRarityLabel:SetTitle("Target: " .. tostring(r) .. " (running)")
            WindUI:Notify({ Title = "Teleport", Content = "Starting teleport to " .. tostring(r), Icon = "check", Duration = 2 })
        else
            WindUI:Notify({ Title = "Teleport", Content = "Failed to start teleport", Icon = "alert-triangle", Duration = 2 })
        end
    end,
})

-- Button: stop all teleporting (rarity, smart tours, reverse tours, console-run teleports)
TsunamiSection:Button({
    Title = "Stop Teleport",
    Desc = "Stop any running teleport operation (all modes)",
    Callback = function()
        -- disable all teleporting flags (short-circuit running loops)
        local stopped = {}
        if autoTeleportByRarity then
            autoTeleportByRarity = false; savedSettings.autoTeleportByRarity = false; table.insert(stopped, "rarity")
        end
        if _G.AutoTourActive then
            _G.AutoTourActive = false; table.insert(stopped, "auto-tour")
        end
        if _G.ReverseTourActive then
            _G.ReverseTourActive = false; table.insert(stopped, "reverse-tour")
        end

        -- persist and update UI status
        pcall(function() saveSettings(savedSettings) end)
        pcall(function() TeleportByRarityLabel:SetTitle("Target: " .. tostring(autoTeleportByRarityTarget or "Common")) end)

        -- best-effort: inform any external console toggles (no-ops if not present)
        pcall(function() if type(_G.XuanHub_ToggleTeleportByRarity) == "function" then _G.XuanHub_ToggleTeleportByRarity() end end)

        -- unified notification
        local msg = (#stopped > 0) and ("Stopped: " .. table.concat(stopped, ", ")) or
            "No teleport operations were active"
        WindUI:Notify({ Title = "Teleport", Content = msg, Icon = "info", Duration = 3 })
    end,
})


-- Background loop: behaves like "Smart Teleport to Last Gap" but stops at mapped gap index
task.spawn(function()
    while scriptRunning do
        if autoTeleportByRarity then
            local ok, err = pcall(function()
                local gapsFolder = findGapsFolder()
                if not gapsFolder then
                    autoTeleportByRarity = false
                    savedSettings.autoTeleportByRarity = false
                    saveSettings(savedSettings)
                    WindUI:Notify({ Title = "Teleport", Content = "No gaps found", Icon = "alert-triangle", Duration = 3 })
                    TeleportByRarityLabel:SetTitle("Target: " .. tostring(autoTeleportByRarityTarget or "Common"))
                    return
                end

                local entries = collectGapEntries(gapsFolder)
                if #entries == 0 then
                    autoTeleportByRarity = false
                    savedSettings.autoTeleportByRarity = false
                    saveSettings(savedSettings)
                    WindUI:Notify({ Title = "Teleport", Content = "No gap entries", Icon = "alert-triangle", Duration = 3 })
                    TeleportByRarityLabel:SetTitle("Target: " .. tostring(autoTeleportByRarityTarget or "Common"))
                    return
                end

                local targetRarity = tostring(autoTeleportByRarityTarget or "Common")
                local targetIdx = RARITY_TO_GAP[targetRarity]
                if not targetIdx then
                    WindUI:Notify({ Title = "Teleport", Content = "Invalid target rarity", Icon = "alert-triangle", Duration = 3 })
                    autoTeleportByRarity = false
                    return
                end

                -- clamp target to available range
                local maxIdx = entries[#entries].idx
                if targetIdx > maxIdx then
                    WindUI:Notify({
                        Title = "Teleport",
                        Content = "Target gap out of range: " .. tostring(targetIdx),
                        Icon =
                        "alert-triangle",
                        Duration = 3
                    })
                    autoTeleportByRarity = false
                    TeleportByRarityLabel:SetTitle("Target: " .. tostring(autoTeleportByRarityTarget or "Common"))
                    return
                end

                -- perform forward tour until reaching targetIdx
                while autoTeleportByRarity do
                    local currentPosIndex = GetNearestGapIndex()
                    if currentPosIndex >= targetIdx then
                        WindUI:Notify({
                            Title = "Teleport",
                            Content = "Reached target gap (" ..
                                tostring(targetRarity) .. ")",
                            Icon = "check",
                            Duration = 2
                        })
                        autoTeleportByRarity = false
                        savedSettings.autoTeleportByRarity = false
                        saveSettings(savedSettings)
                        TeleportByRarityLabel:SetTitle("Target: " .. tostring(autoTeleportByRarityTarget or targetRarity))
                        break
                    end

                    for _, e in ipairs(entries) do
                        if not autoTeleportByRarity then break end
                        if e.idx > currentPosIndex and e.idx <= targetIdx then
                            local ok2, pos = pcall(function()
                                if e.inst and e.inst.GetModelCFrame then
                                    return e.inst:GetModelCFrame().Position
                                elseif e.part then
                                    return e.part.Position
                                end
                            end)
                            if ok2 and pos then
                                local targetPos = (pos + Vector3.new(0, 3, 0))

                                local blockedNotified = false
                                while not IsPathClear(targetPos) and autoTeleportByRarity do
                                    if not blockedNotified then
                                        pcall(function()
                                            WindUI:Notify({
                                                Title = "Teleport",
                                                Content = "Gap blocked — waiting: " ..
                                                    tostring(e.name),
                                                Icon = "alert-triangle",
                                                Duration = 3
                                            })
                                        end)
                                        print("[XuanHub] TeleportByRarity: waiting for gap to clear:", e.name)
                                        blockedNotified = true
                                    end
                                    task.wait(0.12)
                                end

                                if blockedNotified and autoTeleportByRarity then
                                    pcall(function()
                                        WindUI:Notify({
                                            Title = "Teleport",
                                            Content = "Gap is now clear: " ..
                                                tostring(e.name),
                                            Icon = "check",
                                            Duration = 2
                                        })
                                    end)
                                    print("[XuanHub] TeleportByRarity: gap cleared:", e.name)
                                end

                                SmartMove(targetPos, e.name)
                                task.wait(1.2)
                            end
                        end
                    end

                    task.wait(1)
                end
            end)
            if not ok then
                warn("TeleportByRarity error:", err)
                autoTeleportByRarity = false
                TeleportByRarityLabel:SetTitle("Target: " .. tostring(autoTeleportByRarityTarget or "Common"))
            end
        else
            task.wait(1)
        end
    end
end)

-- Console helpers
_G.XuanHub_TeleportToRarity = function(rarity)
    if rarity and type(rarity) == "string" then
        autoTeleportByRarityTarget = rarity
        savedSettings.autoTeleportByRarityTarget = rarity
        saveSettings(savedSettings)
        autoTeleportByRarity = true
        savedSettings.autoTeleportByRarity = true
        saveSettings(savedSettings)
        return true
    end
    return false
end

_G.XuanHub_ToggleTeleportByRarity = function()
    autoTeleportByRarity = not autoTeleportByRarity
    savedSettings.autoTeleportByRarity = autoTeleportByRarity
    saveSettings(savedSettings)
    return autoTeleportByRarity
end

-- Debug helper: reports which Gaps folder would be used and child count (non-destructive)
_G.XuanHub_FindGapsFolderInfo = function()
    local f = findGapsFolder()
    if not f then
        return nil, "no gaps found"
    end
    local parentName = f.Parent and f.Parent.Name or "<unknown>"
    local count = #f:GetChildren()
    return f, string.format("found: %s (parent: %s) — children=%d", f:GetFullName(), parentName, count)
end

-- ================= BASE TAB =================
local UpgBase = BaseTab:Section({ Title = "Main", Opened = true, })

-- VIP Walls section
local VIPWallsSection = BaseTab:Section({ Title = "VIP Walls", Opened = true, })

-- Unlock Default Map VIP Walls
VIPWallsSection:Button({
    Title = "Unlock VIP Walls",
    Desc = "Disable Shield of VIP Walls (Default Map)",
    Locked = false,
    Callback = function()
        local ok, err = pcall(function()
            local defaultMap = workspace:FindFirstChild("DefaultMap_SharedInstances")
            if not defaultMap then
                WindUI:Notify({ Title = "VIP Walls", Content = "Map not found", Icon = "alert-triangle", Duration = 3 })
                return
            end

            local walls = defaultMap:FindFirstChild("VIPWalls")
            if not walls then
                WindUI:Notify({ Title = "VIP Walls", Content = "VIPWalls not found", Icon = "alert-triangle", Duration = 3 })
                return
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                end
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("TouchTransmitter") then
                    v:Destroy()
                end
            end

            WindUI:Notify({ Title = "VIP Walls", Content = "Default Map VIP Walls unlocked", Icon = "check", Duration = 3 })
        end)
        if not ok then
            WindUI:Notify({ Title = "VIP Walls", Content = "Failed to unlock: " .. tostring(err), Icon = "alert-triangle", Duration = 4 })
        end
    end
})

-- Unlock Mars Map VIP Walls
VIPWallsSection:Button({
    Title = "Unlock Mars Map VIP Wall",
    Desc = "Disable Shield of Mars Map VIP Walls",
    Locked = false,
    Callback = function()
        local ok, err = pcall(function()
            local marsMap = workspace:FindFirstChild("MarsMap_SharedInstances")
            if not marsMap then
                WindUI:Notify({ Title = "VIP Walls", Content = "Map not found", Icon = "alert-triangle", Duration = 3 })
                return
            end

            local walls = marsMap:FindFirstChild("VIPWalls")
            if not walls then
                WindUI:Notify({ Title = "VIP Walls", Content = "VIPWalls not found in Mars Map", Icon = "alert-triangle", Duration = 3 })
                return
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                end
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("TouchTransmitter") then
                    v:Destroy()
                end
            end

            WindUI:Notify({ Title = "VIP Walls", Content = "Mars Map VIP Walls unlocked", Icon = "check", Duration = 3 })
        end)
        if not ok then
            WindUI:Notify({ Title = "VIP Walls", Content = "Failed to unlock: " .. tostring(err), Icon = "alert-triangle", Duration = 4 })
        end
    end
})

-- Unlock Radioactive VIP Walls
VIPWallsSection:Button({
    Title = "Unlock Radioactive VIP Walls",
    Desc = "Disable Shield of Radioactive VIP Walls",
    Locked = false,
    Callback = function()
        local ok, err = pcall(function()
            local rmap = workspace:FindFirstChild("RadioactiveMap_SharedInstances")
            if not rmap then
                WindUI:Notify({ Title = "VIP Walls", Content = "Map not found", Icon = "alert-triangle", Duration = 3 })
                return
            end

            local walls = rmap:FindFirstChild("VIPWalls")
            if not walls then
                WindUI:Notify({ Title = "VIP Walls", Content = "VIPWalls not found", Icon = "alert-triangle", Duration = 3 })
                return
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                end
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("TouchTransmitter") then
                    v:Destroy()
                end
            end

            WindUI:Notify({ Title = "VIP Walls", Content = "Radioactive VIP Walls unlocked", Icon = "check", Duration = 3 })
        end)
        if not ok then
            WindUI:Notify({ Title = "VIP Walls", Content = "Failed to unlock: " .. tostring(err), Icon = "alert-triangle", Duration = 4 })
        end
    end
})

-- Unlock Money Map VIP Walls
VIPWallsSection:Button({
    Title = "Unlock Money Map VIP Walls",
    Desc = "Disable Shield of Money Map VIP Walls",
    Locked = false,
    Callback = function()
        local ok, err = pcall(function()
            local mmap = workspace:FindFirstChild("MoneyMap_SharedInstances")
            if not mmap then
                WindUI:Notify({ Title = "VIP Walls", Content = "Map not found", Icon = "alert-triangle", Duration = 3 })
                return
            end

            local walls = mmap:FindFirstChild("VIPWalls")
            if not walls then
                WindUI:Notify({ Title = "VIP Walls", Content = "VIPWalls not found", Icon = "alert-triangle", Duration = 3 })
                return
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                end
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("TouchTransmitter") then
                    v:Destroy()
                end
            end

            WindUI:Notify({ Title = "VIP Walls", Content = "Money Map VIP Walls unlocked", Icon = "check", Duration = 3 })
        end)
        if not ok then
            WindUI:Notify({ Title = "VIP Walls", Content = "Failed to unlock: " .. tostring(err), Icon = "alert-triangle", Duration = 4 })
        end
    end
})

-- Unlock Arcade Map VIP Walls
VIPWallsSection:Button({
    Title = "Unlock Arcade Map VIP Walls",
    Desc = "Disable Shield of Arcade Map VIP Walls",
    Locked = false,
    Callback = function()
        local ok, err = pcall(function()
            local arcadeMap = workspace:FindFirstChild("ArcadeMap_SharedInstances")
            if not arcadeMap then
                WindUI:Notify({ Title = "VIP Walls", Content = "Map not found", Icon = "alert-triangle", Duration = 3 })
                return
            end

            local walls = arcadeMap:FindFirstChild("VIPWalls")
            if not walls then
                WindUI:Notify({ Title = "VIP Walls", Content = "VIPWalls not found", Icon = "alert-triangle", Duration = 3 })
                return
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                end
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("TouchTransmitter") then
                    v:Destroy()
                end
            end

            WindUI:Notify({ Title = "VIP Walls", Content = "Arcade Map VIP Walls unlocked", Icon = "check", Duration = 3 })
        end)
        if not ok then
            WindUI:Notify({ Title = "VIP Walls", Content = "Failed to unlock: " .. tostring(err), Icon = "alert-triangle", Duration = 4 })
        end
    end
})

-- Unlock Valentines Map VIP Walls
VIPWallsSection:Button({
    Title = "Unlock Valentines Map VIP Walls",
    Desc = "Disable Shield of Valentines Map VIP Walls",
    Locked = false,
    Callback = function()
        local ok, err = pcall(function()
            local valentinesMap = workspace:FindFirstChild("ValentinesMap_SharedInstances")
            if not valentinesMap then
                WindUI:Notify({ Title = "VIP Walls", Content = "Map not found", Icon = "alert-triangle", Duration = 3 })
                return
            end

            local walls = valentinesMap:FindFirstChild("VIPWalls")
            if not walls then
                WindUI:Notify({ Title = "VIP Walls", Content = "VIPWalls not found", Icon = "alert-triangle", Duration = 3 })
                return
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                end
            end

            for _, v in pairs(walls:GetDescendants()) do
                if v:IsA("TouchTransmitter") then
                    v:Destroy()
                end
            end

            WindUI:Notify({ Title = "VIP Walls", Content = "Valentines Map VIP Walls unlocked", Icon = "check", Duration = 3 })
        end)
        if not ok then
            WindUI:Notify({ Title = "VIP Walls", Content = "Failed to unlock: " .. tostring(err), Icon = "alert-triangle", Duration = 4 })
        end
    end
})

-- Auto Remove VIP Walls Toggle
VIPWallsSection:Toggle({
    Title = "Auto Remove VIP Walls",
    Desc = "Automatically remove VIP walls from all maps ",
    Icon = "check",
    Value = savedSettings.autoRemoveVIPWalls,
    Callback = function(state)
        autoRemoveVIPWalls = state
        savedSettings.autoRemoveVIPWalls = state
        saveSettings(savedSettings)
        if state then
            WindUI:Notify({ Title = "VIP Walls", Content = "Auto remove VIP walls enabled", Icon = "check", Duration = 3 })
        else
            WindUI:Notify({ Title = "VIP Walls", Content = "Auto remove VIP walls disabled", Icon = "check", Duration = 3 })
        end
    end
})

-- Auto Remove VIP Walls Background Loop
task.spawn(function()
    while scriptRunning do
        if autoRemoveVIPWalls then
            pcall(function()
                local mapsToCheck = {
                    { name = "DefaultMap_SharedInstances",     displayName = "Default Map" },
                    { name = "MarsMap_SharedInstances",        displayName = "Mars Map" },
                    { name = "RadioactiveMap_SharedInstances", displayName = "Radioactive Map" },
                    { name = "MoneyMap_SharedInstances",       displayName = "Money Map" },
                    { name = "ArcadeMap_SharedInstances",      displayName = "Arcade Map" },
                    { name = "ValentinesMap_SharedInstances",  displayName = "Valentines Map" },
                }

                for _, mapInfo in ipairs(mapsToCheck) do
                    local mapInstance = workspace:FindFirstChild(mapInfo.name)
                    if mapInstance then
                        local walls = mapInstance:FindFirstChild("VIPWalls")
                        if walls then
                            for _, v in pairs(walls:GetDescendants()) do
                                if v:IsA("BasePart") then
                                    v.CanCollide = false
                                end
                            end

                            for _, v in pairs(walls:GetDescendants()) do
                                if v:IsA("TouchTransmitter") then
                                    v:Destroy()
                                end
                            end
                        end
                    end
                end
            end)
            task.wait(3)
        else
            task.wait(1)
        end
    end
end)

-- Utilities section (visible)
local UtilitiesSection = BaseTab:Section({ Title = "Utilities", Opened = true, })

local UpgBaseOnce = UpgBase:Button({
    Title = "Upgrade Base",
    Desc = "Purchase one base upgrade",
    Locked = false,
    Callback = function()
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
                "RE/Plot.UpgradeBase"):FireServer()
        end)
        WindUI:Notify({
            Title = "Upgraded",
            Content = "Base upgrade purchased!",
            Icon = "check",
            Duration = 3,
        })
    end
})

-- Upgrade Carry (manual)
local UpgCarryOnce = UpgBase:Button({
    Title = "Upgrade Carry",
    Desc = "Purchase one carry upgrade",
    Locked = false,
    Callback = function()
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("UpgradeCarry")
                :InvokeServer()
        end)
        WindUI:Notify({
            Title = "Upgraded",
            Content = "Carry upgrade purchased!",
            Icon = "check",
            Duration = 3,
        })
    end
})

-- Upgrade Jump (manual)
local UpgJumpOnce = UpgBase:Button({
    Title = "Upgrade Jump",
    Desc = "Purchase one jump upgrade",
    Locked = false,
    Callback = function()
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
                "RF/UpgradeJump"):InvokeServer()
        end)
        WindUI:Notify({
            Title = "Upgraded",
            Content = "Jump upgrade purchased!",
            Icon = "check",
            Duration = 3,
        })
    end
})

-- Bring Back Celestial Timer
UpgBase:Button({
    Title = "Bring Back Celestial Timer",
    Desc = "Show the Celestial Timer visibility",
    Locked = false,
    Callback = function()
        local playerGui = player:FindFirstChild("PlayerGui")
        if playerGui then
            local celestialTimer = playerGui:FindFirstChild("CelestialTimeLeft")
            if celestialTimer then
                celestialTimer.Enabled = not celestialTimer.Enabled
                local status = celestialTimer.Enabled and "shown" or "hidden"
                WindUI:Notify({
                    Title = "Celestial Timer",
                    Content = "Timer " .. status,
                    Icon = "check",
                    Duration = 3,
                })
            else
                WindUI:Notify({
                    Title = "Celestial Timer",
                    Content = "Timer not found",
                    Icon = "alert-triangle",
                    Duration = 3,
                })
            end
        end
    end
})

-- Unlock Zoom Limit
UtilitiesSection:Toggle({
    Title = "Unlock Zoom Limit",
    Desc = "Unlock camera zoom limits",
    Icon = "check",
    Value = savedSettings.unlockZoom,
    Callback = function(state)
        if state then
            enableUnlockZoom()
        else
            disableUnlockZoom()
        end
        savedSettings.unlockZoom = state
        saveSettings(savedSettings)
    end
})

-- Wider hitbox helpers
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local BASE_SIZE = Vector3.new(4, 4, 4)
local MAX_SIZE = Vector3.new(150, 150, 150)

-- Cache for optimization
local lastHitboxUpdate = 0
local UPDATE_INTERVAL = 0.1 -- Update every 0.1 seconds instead of every frame
local lastNearbyPlayers = {}
local toolCollectionDirty = true

local function _collectToolHitboxes()
    if not toolCollectionDirty then return end
    toolCollectionDirty = false
    
    -- Only clear and rebuild if needed
    local newTracking = {}
    
    local function findToolHitbox(tool)
        -- Try common hitbox names first
        local hb = tool:FindFirstChild("Hitbox") or tool:FindFirstChild("hitbox") or 
                   tool:FindFirstChild("Handle") or tool:FindFirstChild("Hit")
        
        -- If still not found, get first BasePart
        if not hb then
            for _, child in ipairs(tool:GetChildren()) do
                if child:IsA("BasePart") then
                    hb = child
                    break
                end
            end
        end
        
        return hb
    end
    
    -- Backpack
    if LocalPlayer:FindFirstChild("Backpack") then
        for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                local hb = findToolHitbox(tool)
                if hb and hb:IsA("BasePart") then
                    -- Preserve original values if already tracked
                    if _widerHitbox_tracking[hb] then
                        newTracking[hb] = _widerHitbox_tracking[hb]
                    else
                        newTracking[hb] = { part = hb, origSize = hb.Size, origTransparency = hb.Transparency }
                    end
                end
            end
        end
    end
    
    -- Character (equipped)
    if LocalPlayer.Character then
        for _, tool in ipairs(LocalPlayer.Character:GetChildren()) do
            if tool:IsA("Tool") then
                local hb = findToolHitbox(tool)
                if hb and hb:IsA("BasePart") then
                    if _widerHitbox_tracking[hb] then
                        newTracking[hb] = _widerHitbox_tracking[hb]
                    else
                        newTracking[hb] = { part = hb, origSize = hb.Size, origTransparency = hb.Transparency }
                    end
                end
            end
        end
    end
    
    -- Restore any hitboxes that are no longer tracked
    for hb, meta in pairs(_widerHitbox_tracking) do
        if not newTracking[hb] then
            pcall(function()
                if meta.part and meta.origSize then meta.part.Size = meta.origSize end
                if meta.part and meta.origTransparency then meta.part.Transparency = meta.origTransparency end
            end)
        end
    end
    
    _widerHitbox_tracking = newTracking
end

local function _applyWiderHitboxes()
    local currentTime = tick()
    
    -- Throttle updates to reduce lag
    if currentTime - lastHitboxUpdate < UPDATE_INTERVAL then return end
    lastHitboxUpdate = currentTime
    
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    
    _collectToolHitboxes()
    if not next(_widerHitbox_tracking) then return end

    -- find nearby players (cached)
    local hrp = LocalPlayer.Character.HumanoidRootPart
    local nearby = {}
    local hrpPos = hrp.Position
    
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            local targetHrp = pl.Character.HumanoidRootPart
            local d = (targetHrp.Position - hrpPos).Magnitude
            if d <= 50 then 
                table.insert(nearby, targetHrp) 
            end
        end
    end

    for hb, meta in pairs(_widerHitbox_tracking) do
        if hb and hb.Parent then
            if #nearby == 0 then
                hb.Size = meta.origSize or BASE_SIZE
                hb.Transparency = meta.origTransparency or 1
                hb.CanCollide = false
            else
                local targetPos = hrpPos
                if #nearby == 1 then
                    local dir = (nearby[1].Position - hrpPos).Unit
                    targetPos = nearby[1].Position + dir * 2
                else
                    local total = Vector3.new()
                    for _, p in ipairs(nearby) do
                        total = total + p.Position
                    end
                    targetPos = total / #nearby
                end
                local finalSize = (#nearby == 1) and Vector3.new(widerHitboxWidth, widerHitboxWidth, widerHitboxWidth + 8) or MAX_SIZE
                hb.Size = finalSize
                hb.Position = targetPos
                hb.Transparency = 0.7
                hb.CanCollide = false
            end
        end
    end
    
    lastNearbyPlayers = nearby
end

local function startWiderHitbox()
    if widerHitboxConn then return end
    widerHitboxEnabled = true
    toolCollectionDirty = true
    
    widerHitboxConn = RunService.Heartbeat:Connect(function()
        if widerHitboxEnabled then _applyWiderHitboxes() end
    end)
    
    -- react to tool/character changes
    if LocalPlayer:FindFirstChild("Backpack") then
        LocalPlayer.Backpack.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                toolCollectionDirty = true
            end
        end)
        LocalPlayer.Backpack.ChildRemoved:Connect(function(child)
            if child:IsA("Tool") then
                toolCollectionDirty = true
            end
        end)
    end
    
    LocalPlayer.CharacterAdded:Connect(function(char)
        toolCollectionDirty = true
        task.wait(1)
        toolCollectionDirty = true
    end)
    
    if LocalPlayer.Character then
        LocalPlayer.Character.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                toolCollectionDirty = true
            end
        end)
        LocalPlayer.Character.ChildRemoved:Connect(function(child)
            if child:IsA("Tool") then
                toolCollectionDirty = true
            end
        end)
    end
    
    WindUI:Notify({ Title = "Utilities", Content = "Wider hitbox enabled", Icon = "check", Duration = 2 })
end

local function stopWiderHitbox()
    widerHitboxEnabled = false
    if widerHitboxConn then
        widerHitboxConn:Disconnect()
        widerHitboxConn = nil
    end
    -- restore originals
    for hb, meta in pairs(_widerHitbox_tracking) do
        pcall(function()
            if meta.part and meta.origSize then meta.part.Size = meta.origSize end
            if meta.part and meta.origTransparency then meta.part.Transparency = meta.origTransparency end
            if meta.part then meta.part.CanCollide = false end
        end)
    end
    table.clear(_widerHitbox_tracking)
    WindUI:Notify({ Title = "Utilities", Content = "Wider hitbox disabled", Icon = "check", Duration = 2 })
end

-- Utilities: Wider hitbox UI
UtilitiesSection:Toggle({
    Title = "Enable Wider Hitbox",
    Desc = "Expand tool hitboxes when players are nearby",
    Icon = "check",
    Value = savedSettings.hitboxEnabled,
    Callback = function(state)
        savedSettings.hitboxEnabled = state
        saveSettings(savedSettings)
        if state then
            widerHitboxWidth = tonumber(savedSettings.hitboxWidth) or 70
            startWiderHitbox()
        else
            stopWiderHitbox()
        end
    end
})

UtilitiesSection:Slider({
    Title = "Hitbox Width",
    Desc = "How wide the hitbox becomes (studs)",
    Step = 1,
    Value = { Min = 20, Max = 120, Default = savedSettings.hitboxWidth or 70 },
    Callback = function(value)
        widerHitboxWidth = math.clamp(tonumber(value) or 70, 8, 200)
        savedSettings.hitboxWidth = widerHitboxWidth
        saveSettings(savedSettings)
    end
})

-- Fly + NoClip Toggle
UtilitiesSection:Toggle({
    Title = "Fly + NoClip",
    Desc = "Fly around and pass through walls ",
    Icon = "check",
    Value = false,
    Callback = function(state)
        flyMode = state

        if flyMode then
            local character = player.Character
            if not character then
                WindUI:Notify({ Title = "Utilities", Content = "Character not found", Icon = "alert-triangle", Duration = 2 })
                return
            end

            local root = character:FindFirstChild("HumanoidRootPart")
            if not root then
                WindUI:Notify({ Title = "Utilities", Content = "HumanoidRootPart not found", Icon = "alert-triangle", Duration = 2 })
                return
            end

            if flyBodyVelocity then
                flyBodyVelocity:Destroy()
            end

            flyBodyVelocity = Instance.new("BodyVelocity")
            flyBodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
            flyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            flyBodyVelocity.Parent = root

            if flyConnection then
                flyConnection:Disconnect()
            end

            flyConnection = RunService.Heartbeat:Connect(function()
                if not root or not flyBodyVelocity then return end

                local camera = workspace.CurrentCamera
                local moveDir = Vector3.new(0, 0, 0)

                if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.W) then
                    moveDir = moveDir + camera.CFrame.LookVector
                end
                if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.S) then
                    moveDir = moveDir - camera.CFrame.LookVector
                end
                if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.A) then
                    moveDir = moveDir - camera.CFrame.RightVector
                end
                if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.D) then
                    moveDir = moveDir + camera.CFrame.RightVector
                end
                if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Space) then
                    moveDir = moveDir + Vector3.new(0, 1, 0)
                end
                if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.LeftShift) then
                    moveDir = moveDir - Vector3.new(0, 1, 0)
                end

                if moveDir.Magnitude > 0 then
                    flyBodyVelocity.Velocity = moveDir.Unit * 50
                else
                    flyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
                end
            end)

            if noclipConnection then
                noclipConnection:Disconnect()
            end

            noclipConnection = RunService.Stepped:Connect(function()
                if player.Character then
                    for _, part in pairs(player.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)

            WindUI:Notify({ Title = "Utilities", Content = "Fly + NoClip enabled", Icon = "check", Duration = 2 })
        else
            if flyConnection then
                flyConnection:Disconnect()
                flyConnection = nil
            end

            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end

            if flyBodyVelocity then
                flyBodyVelocity:Destroy()
                flyBodyVelocity = nil
            end

            local character = player.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end

            WindUI:Notify({ Title = "Utilities", Content = "Fly + NoClip disabled", Icon = "check", Duration = 2 })
        end
    end
})

-- Buttons moved from Main (simplified)
local SellAllBtn = UpgBase:Button({
    Title = "Sell All Inventory",
    Desc = "Sell your entire inventory (confirmation required)",
    Locked = false,
    Callback = function()
        local Popup = WindUI:Popup({
            Title = "Confirm Sell All",
            Icon = "alert-triangle",
            Content = "Are you sure you want to sell ALL brainrots in your inventory?\nThis action cannot be undone!",
            Buttons = {
                {
                    Title = "Sell All",
                    Icon = "trash-2",
                    Variant = "Primary",
                    Callback = function()
                        pcall(function()
                            local result = game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions")
                                :WaitForChild("SellAll"):InvokeServer()
                            if result == false or result == nil then
                                WindUI:Notify({
                                    Title = "Sold",
                                    Content = "You don't have any Brainrots in your Inventory.",
                                    Icon = "alert-triangle",
                                    Duration = 3,
                                })
                            else
                                WindUI:Notify({
                                    Title = "Sold",
                                    Content = "Successfully Sold All Brainrots!",
                                    Icon = "check",
                                    Duration = 3,
                                })
                            end
                        end)
                    end
                },
                {
                    Title = "Cancel",
                    Icon = "x",
                    Variant = "Secondary",
                    Callback = function()
                        Popup:Close()
                        WindUI:Notify({
                            Title = "Cancelled",
                            Content = "Sell all cancelled",
                            Icon = "info",
                            Duration = 2,
                        })
                    end
                }
            }
        })
    end
})

local SellHeldBtn = UpgBase:Button({
    Title = "Sell Held Tool",
    Desc = "Sells the brainrot you are currently holding",
    Locked = false,
    Callback = function()
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunctions"):WaitForChild("SellTool"):InvokeServer()
        end)
        WindUI:Notify({
            Title = "Sold",
            Content = "Held tool sold!",
            Icon = "check",
            Duration = 3,
        })
    end
})


-- ================= EVENT TAB =================
local RadioactiveSection = EventTab:Section({
    Title = "Radioactive Event",
    Opened = true,
})

-- Auto Collect Radioactive
RadioactiveSection:Toggle({
    Title = "Auto Collect Radioactive Coins",
    Desc = "Automatically Collect Radioactive Coins",
    Icon = "check",
    Value = savedSettings.autoCollectRadioactive,
    Callback = function(state)
        autoCollectRadioactive = state
        savedSettings.autoCollectRadioactive = state
        saveSettings(savedSettings)
    end
})

RadioactiveSection:Space()

-- Auto Spin
RadioactiveSection:Toggle({
    Title = "Auto Spin Radioactive Wheel",
    Desc = "Automatically spins the radioactive wheel",
    Icon = "check",
    Value = savedSettings.autoSpin,
    Callback = function(state)
        spinning = state
        savedSettings.autoSpin = state
        saveSettings(savedSettings)
    end
})

RadioactiveSection:Input({
    Title = "Spin Delay",
    Value = tostring(savedSettings.spinDelay),
    Placeholder = "0.5",
    Callback = function(value)
        local delay = tonumber(value)
        if delay and delay >= 0.1 then
            savedSettings.spinDelay = delay
            saveSettings(savedSettings)
        end
    end
})

RadioactiveSection:Space()

-- Auto Obby
RadioactiveSection:Toggle({
    Title = "Auto Complete Radioactive Obby",
    Desc = "Automatically complete the Radioactive obby ",
    Icon = "check",
    Value = savedSettings.autoObby,
    Callback = function(state)
        autoObby = state
        savedSettings.autoObby = state
        saveSettings(savedSettings)
    end
})

-- UFO Event
local UFOSection = EventTab:Section({
    Title = "UFO Event",
    Opened = true,
})

UFOSection:Toggle({
    Title = "Auto Collect UFO Coins",
    Desc = "Automatically collects UFO coins",
    Icon = "check",
    Value = savedSettings.autoCollectUFO,
    Callback = function(state)
        autoCollectUFO = state
        savedSettings.autoCollectUFO = state
        saveSettings(savedSettings)
    end
})

UFOSection:Toggle({
    Title = "Auto Spin UFO Wheel",
    Desc = "Automatically spins the UFO wheel",
    Icon = "check",
    Value = savedSettings.autoSpinUFO,
    Callback = function(state)
        autoSpinUFO = state
        savedSettings.autoSpinUFO = state
        saveSettings(savedSettings)
    end
})

-- Money Event
local MoneySection = EventTab:Section({
    Title = "Money Event",
    Opened = true,
})

MoneySection:Toggle({
    Title = "Auto Collect Gold Bar",
    Desc = "Automatically collect Gold Bars",
    Icon = "check",
    Value = savedSettings.autoCollectGoldBar,
    Callback = function(state)
        autoCollectGoldBar = state
        savedSettings.autoCollectGoldBar = state
        saveSettings(savedSettings)
    end
})

MoneySection:Toggle({
    Title = "Auto Spin Money Wheel",
    Desc = "Automatically spin the money wheel",
    Icon = "check",
    Value = savedSettings.autoSpinMoneyWheel,
    Callback = function(state)
        autoSpinMoneyWheel = state
        savedSettings.autoSpinMoneyWheel = state
        saveSettings(savedSettings)
    end
})

MoneySection:Toggle({
    Title = "Auto Complete Money Obbies",
    Desc = "Automatically complete 3 Money obbies",
    Icon = "check",
    Value = savedSettings.autoCompleteMoneyObby,
    Callback = function(state)
        autoCompleteMoneyObby = state
        savedSettings.autoCompleteMoneyObby = state
        saveSettings(savedSettings)
    end
})

-- New: Auto-rejoin after completing 3 money obby cycles
MoneySection:Toggle({
    Title = "Auto Rejoin After Money Obbies",
    Desc = "When enabled, rejoin the server automatically after 3 completed obby cycles",
    Icon = "check",
    Value = savedSettings.autoRejoinAfterMoneyObby,
    Callback = function(state)
        autoRejoinAfterMoneyObby = state
        savedSettings.autoRejoinAfterMoneyObby = state
        saveSettings(savedSettings)
        WindUI:Notify({
            Title = "Money Obby",
            Content = (state and "Auto-rejoin enabled" or "Auto-rejoin disabled"),
            Icon =
            "info",
            Duration = 2
        })
    end
})

-- Arcade Event Section
local ArcadeSection = EventTab:Section({
    Title = "Arcade Event",
    Opened = true,
})

ArcadeSection:Toggle({
    Title = "Auto Collect Game Console",
    Desc = "Automatically collect from Game Console",
    Icon = "check",
    Value = savedSettings.autoCollectGameConsole,
    Callback = function(state)
        autoCollectGameConsole = state
        savedSettings.autoCollectGameConsole = state
        saveSettings(savedSettings)
    end
})

ArcadeSection:Toggle({
    Title = "Auto Collect Ticket",
    Desc = "Automatically collect Arcade Tickets",
    Icon = "check",
    Value = savedSettings.autoCollectArcadeTicket,
    Callback = function(state)
        autoCollectArcadeTicket = state
        savedSettings.autoCollectArcadeTicket = state
        saveSettings(savedSettings)
    end
})

ArcadeSection:Toggle({
    Title = "Auto Spin Arcade Wheel",
    Desc = "Automatically spin the Arcade wheel",
    Icon = "check",
    Value = savedSettings.autoSpinArcadeWheel,
    Callback = function(state)
        autoSpinArcadeWheel = state
        savedSettings.autoSpinArcadeWheel = state
        saveSettings(savedSettings)
    end
})

-- Valentines Event Section
local ValentinesSection = EventTab:Section({
    Title = "Candy (Valentines) Event",
    Opened = true,
})

ValentinesSection:Toggle({
    Title = "Auto Collect Candy",
    Desc = "Automatically collect Valentine's Candy",
    Icon = "check",
    Value = savedSettings.autoCollectCandy,
    Callback = function(state)
        autoCollectCandy = state
        savedSettings.autoCollectCandy = state
        saveSettings(savedSettings)
    end
})

ValentinesSection:Toggle({
    Title = "Auto Collect Valentines Coin",
    Desc = "Automatically collect Valentine's Love Tokens",
    Icon = "check",
    Value = savedSettings.autoCollectValentinesCoin,
    Callback = function(state)
        autoCollectValentinesCoin = state
        savedSettings.autoCollectValentinesCoin = state
        saveSettings(savedSettings)
    end
})

ValentinesSection:Toggle({
    Title = "Auto Spin Valentines Wheel",
    Desc = "Automatically spin the Valentines wheel",
    Icon = "check",
    Value = savedSettings.autoSpinValentinesWheel,
    Callback = function(state)
        autoSpinValentinesWheel = state
        savedSettings.autoSpinValentinesWheel = state
        saveSettings(savedSettings)
    end
})

-- ================= AUTO TAB =================
local AutoSection = AutoTab:Section({ Title = "Auto Features", Opened = true, })

-- Auto Upgrade Base
local AutoUpgradeBaseToggle = AutoSection:Toggle({
    Title = "Auto Upgrade Base",
    Desc = "Automatically upgrades your base",
    Icon = "check",
    Value = savedSettings.autoUpgradeBase,
    Callback = function(state)
        autoUpgradeBase = state
        savedSettings.autoUpgradeBase = state
        saveSettings(savedSettings)
    end
})

-- Auto Collect Money
local AutoCollectMoneyToggle = AutoSection:Toggle({
    Title = "Auto Collect Money",
    Desc = "Automatically collects money from your base",
    Icon = "check",
    Value = savedSettings.autoCollectMoney,
    Callback = function(state)
        collectingMoney = state
        savedSettings.autoCollectMoney = state
        saveSettings(savedSettings)
    end
})

AutoSection:Space()

-- ================= LUCKY BLOCK SECTION =================
local LuckyBlockSection = AutoTab:Section({ Title = "Lucky Block", Opened = true, })

-- Auto Open Lucky Block (select & auto-open a lucky block from Backpack)
LuckyBlockSection:Dropdown({
    Title = "Lucky Block to Open",
    Desc = "Select which Lucky Block to auto-open from your Backpack",
    Values = {
        "All",
        "Radioactive Block", "UFO Block", "Money Block", "Jackpot Block", "Alien Block", "Admin Block",
        "Common Block", "Uncommon Block", "Rare Block", "Epic Block", "Legendary Block", "Mythical Block",
        "Cosmic Block", "Secret Block", "Celestial Block", "Divine Block", "Infinity Block", "Arcade Block",
        "Gamer Block"
    },
    Value = tostring(savedSettings.autoOpenLuckyBlockTarget or "Radioactive Block"),
    Multi = false,
    AllowNone = false,
    SearchBarEnabled = true,
    Callback = function(option)
        autoOpenLuckyBlockTarget = option
        savedSettings.autoOpenLuckyBlockTarget = option
        saveSettings(savedSettings)
        WindUI:Notify({ Title = "Auto Open", Content = "Target set: " .. tostring(option), Icon = "check", Duration = 2 })
    end,
})

LuckyBlockSection:Toggle({
    Title = "Auto Open Lucky Block",
    Desc = "Automatically equip & open matching Lucky Blocks from your Backpack",
    Icon = "check",
    Value = savedSettings.autoOpenLuckyBlock,
    Callback = function(state)
        autoOpenLuckyBlock = state
        savedSettings.autoOpenLuckyBlock = state
        saveSettings(savedSettings)
        WindUI:Notify({ Title = "Auto Open", Content = (state and "Enabled" or "Disabled"), Icon = "info", Duration = 2 })
    end
})

LuckyBlockSection:Slider({
    Title = "Open delay (s)",
    Desc = "Delay after equipping before attempting to open the block",
    Step = 0.1,
    Value = { Min = 0.1, Max = 2, Default = tonumber(savedSettings.autoOpenLuckyBlockDelay) or 0.6 },
    Callback = function(value)
        autoOpenLuckyBlockDelay = tonumber(value) or 0.6
        savedSettings.autoOpenLuckyBlockDelay = autoOpenLuckyBlockDelay
        saveSettings(savedSettings)
    end
})

-- Console helpers for Auto Open Lucky Block
_G.XuanHub_OpenLuckyBlockNow = function(name)
    if type(name) ~= "string" then return false end
    -- trigger one-shot open by temporarily enabling the loop and forcing a quick scan
    local prev = autoOpenLuckyBlock
    autoOpenLuckyBlock = true
    autoOpenLuckyBlockTarget = name
    task.spawn(function()
        task.wait(0.1)
        autoOpenLuckyBlock = prev
    end)
    return true
end


-- One-shot scanner + helpers for Lucky Blocks (matches Attributes.DisplayName or tool.Name)
local function normalizeLuckyName(s)
    if not s then return "" end
    s = tostring(s)
    s = s:gsub("%s*[Bb]lock%s*$", "")
    s = s:gsub("%s+", " ")
    s = s:match("^%s*(.-)%s*$") or s
    return s:lower()
end

local function scanBackpackForLuckyBlock(target)
    local out = {}
    target = normalizeLuckyName(target or autoOpenLuckyBlockTarget or savedSettings.autoOpenLuckyBlockTarget or "")
    if target == "" then return out end
    local bp = player and player:FindFirstChild("Backpack")
    if not bp then return out end

    for _, tool in ipairs(bp:GetChildren()) do
        if tool and tool:IsA("Tool") then
            local ok, disp = pcall(function() return tool:GetAttribute("DisplayName") end)
            local dispName = (ok and disp) or tool.Name
            if normalizeLuckyName(dispName) == target then
                table.insert(out, { tool = tool, display = tostring(dispName), name = tool.Name })
            end
        end
    end

    -- also check equipped tool
    local char = player and player.Character
    if char then
        for _, tool in ipairs(char:GetChildren()) do
            if tool and tool:IsA("Tool") then
                local ok2, disp2 = pcall(function() return tool:GetAttribute("DisplayName") end)
                local dispName2 = (ok2 and disp2) or tool.Name
                if normalizeLuckyName(dispName2) == target then
                    table.insert(out, { tool = tool, display = tostring(dispName2), name = tool.Name, equipped = true })
                end
            end
        end
    end

    return out
end

-- Console helper: scan Backpack for matching lucky block tools
_G.XuanHub_ScanLuckyBlockBackpack = function(name)
    local ok, res = pcall(function() return scanBackpackForLuckyBlock(name or autoOpenLuckyBlockTarget) end)
    if not ok then return nil, tostring(res) end
    return res, (#res .. " match(es)")
end

-- Keep single Open helper (one-shot)
_G.XuanHub_OpenLuckyBlockNow = function(name)
    if type(name) ~= "string" then return false end
    local prev = autoOpenLuckyBlock
    autoOpenLuckyBlock = true
    autoOpenLuckyBlockTarget = name
    task.spawn(function()
        task.wait(0.1)
        autoOpenLuckyBlock = prev
    end)
    return true
end

-- Background loop: Auto Open Lucky Block (same logic as Auto Sell by Rarity)
task.spawn(function()
    while scriptRunning do
        if autoOpenLuckyBlock and autoOpenLuckyBlockTarget ~= "" then
            pcall(function()
                local backpack = player:FindFirstChild("Backpack")
                local character = player.Character
                if not backpack or not character then return end

                local humanoid = character:FindFirstChild("Humanoid")
                if not humanoid then return end

                -- Scan backpack for matching lucky blocks (using DisplayName attribute)
                for _, tool in ipairs(backpack:GetChildren()) do
                    if not autoOpenLuckyBlock then break end

                    if tool:IsA("Tool") then
                        -- Match by DisplayName attribute (fallback to tool.Name)
                        local displayName = tool:GetAttribute("DisplayName") or tool.Name
                        local shouldOpen = false

                        -- Check if we should open this block
                        if autoOpenLuckyBlockTarget == "All" then
                            -- Open any tool that has "Block" in its display name
                            shouldOpen = displayName:find("Block") ~= nil
                        else
                            -- Normalize: strip trailing " Block" if present
                            local normalizedDisplay = displayName:gsub(" Block$", "")
                            local normalizedTarget = autoOpenLuckyBlockTarget:gsub(" Block$", "")
                            shouldOpen = normalizedDisplay == normalizedTarget
                        end

                        if shouldOpen then
                            -- Equip tool (same as Auto Sell)
                            humanoid:EquipTool(tool)
                            task.wait(0.15) -- short wait so game registers the equip

                            -- Random screen click to open (same as executor pattern)
                            pcall(function()
                                local cam = workspace.CurrentCamera
                                if cam and vu then
                                    -- Random position on screen (viewport size)
                                    local vpSize = cam.ViewportSize
                                    local randomX = math.random(vpSize.X * 0.3, vpSize.X * 0.7)
                                    local randomY = math.random(vpSize.Y * 0.3, vpSize.Y * 0.7)
                                    local randomPos = Vector2.new(randomX, randomY)

                                    vu:Button1Down(randomPos, cam.CFrame)
                                    task.wait(0.05)
                                    vu:Button1Up(randomPos, cam.CFrame)
                                end
                            end)

                            task.wait(0.2) -- cooldown between opens

                            print("[XuanHub] Auto-opened Lucky Block:", displayName)
                        end
                    end
                end
            end)
            task.wait(1)
        else
            task.wait(1)
        end
    end
end)

-- Auto Upgrade Carry
local AutoUpgradeCarryToggle = AutoSection:Toggle({
    Title = "Auto Upgrade Carry",
    Desc = "Automatically upgrades carry capacity",
    Icon = "check",
    Value = savedSettings.autoUpgradeCarry,
    Callback = function(state)
        autoUpgradeCarry = state
        savedSettings.autoUpgradeCarry = state
        saveSettings(savedSettings)
    end
})

-- Auto Upgrade Jump
local AutoUpgradeJumpToggle = AutoSection:Toggle({
    Title = "Auto Upgrade Jump",
    Desc = "Automatically upgrades jump power",
    Icon = "check",
    Value = savedSettings.autoUpgradeJump,
    Callback = function(state)
        autoUpgradeJump = state
        savedSettings.autoUpgradeJump = state
        saveSettings(savedSettings)
    end
})

-- Auto Upgrade Speed
local AutoUpgradeSpeedToggle = AutoSection:Toggle({
    Title = "Auto Upgrade Speed",
    Desc = "Automatically upgrades movement speed",
    Icon = "check",
    Value = savedSettings.autoUpgradeSpeed,
    Callback = function(state)
        autoUpgradeSpeed = state
        savedSettings.autoUpgradeSpeed = state
        saveSettings(savedSettings)
    end
})

local SpeedAmountDropdown = AutoSection:Dropdown({
    Title = "Speed Amount",
    Desc = "Select upgrade speed amount",
    Values = { "1", "5", "10" },
    Value = tostring(savedSettings.upgradeSpeedAmount),
    Multi = false,
    AllowNone = false,
    SearchBarEnabled = true,
    Callback = function(option)
        upgradeSpeedAmount = tonumber(option)
        savedSettings.upgradeSpeedAmount = upgradeSpeedAmount
        saveSettings(savedSettings)
        print("Speed amount set to: " .. tostring(option))
    end
})

-- Auto Rebirth
local AutoRebirthToggle = AutoSection:Toggle({
    Title = "Auto Rebirth",
    Desc = "Automatically rebirths when possible",
    Icon = "check",
    Value = savedSettings.autoRebirth,
    Callback = function(state)
        autoRebirth = state
        savedSettings.autoRebirth = state
        saveSettings(savedSettings)
    end
})

AutoSection:Space()

-- ================= SHARED BRAINROT DATA =================
-- Consolidated function to fetch brainrot data once (prevents duplicate require() calls)
local cachedBrainrotsData = nil

local function loadBrainrotsData()
    if cachedBrainrotsData then return cachedBrainrotsData end
    
    pcall(function()
        cachedBrainrotsData = require(ReplicatedStorage.Shared.Config.Brainrots)
    end)
    
    return cachedBrainrotsData
end

-- Get brainrot names for machine dropdowns (using cached data)
local cachedBrainrotNames = nil
local function getBrainrotNamesForMachines()
    -- Return cached result if already processed
    if cachedBrainrotNames then return cachedBrainrotNames end
    
    local names = { "" }
    local data = loadBrainrotsData()
    
    if data and data.BrainrotNames then
        for _, name in ipairs(data.BrainrotNames) do
            table.insert(names, name)
        end
        table.sort(names)
    end
    
    cachedBrainrotNames = names
    return names
end

-- Preload brainrot data asynchronously in background (so it's cached before dropdowns are created)
task.spawn(function()
    loadBrainrotsData() -- Load raw data
    getBrainrotNamesForMachines() -- Process and cache names array
end)

-- Brief delay to ensure preload completes (prevents lag from synchronous processing)
task.wait(0.1)

-- ================= BRAINROT SECTION =================
local BrainrotSection = AutoTab:Section({ Title = "Brainrot", Opened = true, })

-- Get rarities dynamically from game data (using cached data)
local function getRarities()
    local rarities = {}
    local data = loadBrainrotsData()
    
    if data and data.Chances then
        for rarity, _ in pairs(data.Chances) do
            table.insert(rarities, rarity)
        end
        table.sort(rarities)
    end
    
    return rarities
end

-- Auto Sell by Rarity Dropdown
BrainrotSection:Dropdown({
    Title = "Select Rarities to Sell",
    Desc = "Choose which rarities to auto-sell",
    Values = getRarities(),
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(selected)
        sellRarities = selected

        if #selected > 0 then
            local rarityList = table.concat(selected, ", ")
            WindUI:Notify({
                Title = "Auto Sell",
                Content = "Will sell: " .. rarityList,
                Icon = "check",
                Duration = 3,
            })
        end
    end
})

-- Auto Sell by Rarity Toggle
BrainrotSection:Toggle({
    Title = "Auto Sell by Rarity",
    Desc = "Automatically sell selected rarities",
    Icon = "check",
    Value = false,
    Callback = function(state)
        autoSellByRarity = state

        if state then
            if #sellRarities == 0 then
                WindUI:Notify({
                    Title = "Auto Sell",
                    Content = "Please select rarities first!",
                    Icon = "alert-triangle",
                    Duration = 3,
                })
                autoSellByRarity = false
            else
                WindUI:Notify({
                    Title = "Auto Sell",
                    Content = "Auto Sell enabled",
                    Icon = "check",
                    Duration = 3,
                })
            end
        end
    end
})

BrainrotSection:Space()

-- Auto Sell by Name - Use shared brainrot data (no duplicate require)
BrainrotSection:Dropdown({
    Title = "Select Brainrot Names to Sell",
    Desc = "Choose which brainrot you want to sell",
    Values = getBrainrotNamesForMachines(),
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(selected)
        -- Store selected brainrot names
        sellBrainrotNames = selected

        if #sellBrainrotNames > 0 then
            WindUI:Notify({
                Title = "Auto Sell by Name",
                Content = "Selected " .. #sellBrainrotNames .. " brainrot(s) to sell",
                Icon = "check",
                Duration = 2,
            })
        end
    end
})

BrainrotSection:Toggle({
    Title = "Auto Sell by Name",
    Desc = "Automatically sell selected brainrot names",
    Icon = "check",
    Value = false,
    Callback = function(state)
        autoSellByName = state

        if state then
            if #sellBrainrotNames == 0 then
                WindUI:Notify({
                    Title = "Auto Sell by Name",
                    Content = "Please select brainrot names first!",
                    Icon = "alert-triangle",
                    Duration = 3,
                })
                autoSellByName = false
            else
                WindUI:Notify({
                    Title = "Auto Sell by Name",
                    Content = "Auto Sell by Name enabled",
                    Icon = "check",
                    Duration = 3,
                })
            end
        end
    end
})

BrainrotSection:Space()

-- Auto Upgrade Brainrot - Helper functions for dynamic dropdown refresh
local function getBrainrotOptions()
    local tempData = scanBaseBrainrots()
    brainrotSlotData = tempData -- Update global cache
    local labels = {}
    for _, data in ipairs(tempData) do
        table.insert(labels, data.label)
    end
    return labels
end

local function refreshBrainrotDropdown(dropdown)
    local newLabels = getBrainrotOptions()
    dropdown:Refresh(newLabels)

    -- Clear selection if previously selected items no longer exist
    local validTargets = {}
    for _, target in ipairs(upgradeBrainrotTargets) do
        for _, label in ipairs(newLabels) do
            if label == target then
                table.insert(validTargets, target)
                break
            end
        end
    end
    upgradeBrainrotTargets = validTargets
end

-- Initial scan
local initialBrainrotLabels = getBrainrotOptions()

BrainrotSection:Button({
    Title = "Refresh Base Brainrots",
    Desc = "Re-scan your base and update the dropdown",
    Callback = function()
        refreshBrainrotDropdown(BrainrotUpgradeDropdown)

        if #brainrotSlotData > 0 then
            WindUI:Notify({
                Title = "Base Scan",
                Content = "Found " .. #brainrotSlotData .. " brainrot(s) in your base",
                Icon = "check",
                Duration = 3,
            })
        else
            WindUI:Notify({
                Title = "Base Scan",
                Content = "No brainrots found. Make sure you have brainrots placed in slots.",
                Icon = "alert-triangle",
                Duration = 3,
            })
        end
    end
})

BrainrotUpgradeDropdown = BrainrotSection:Dropdown({
    Title = "Select Brainrots to Upgrade",
    Desc = "Multi-select brainrots from your base",
    Values = initialBrainrotLabels,
    Value = {},
    Multi = true,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(selected)
        upgradeBrainrotTargets = selected
        if #selected > 0 then
            WindUI:Notify({
                Title = "Auto Upgrade",
                Content = "Selected " .. #selected .. " brainrot(s) to upgrade",
                Icon = "check",
                Duration = 2,
            })
        end
    end
})

BrainrotSection:Toggle({
    Title = "Auto Upgrade Brainrot",
    Desc = "Automatically upgrade selected brainrots",
    Icon = "check",
    Value = false,
    Callback = function(state)
        autoUpgradeBrainrot = state

        if state then
            if #upgradeBrainrotTargets == 0 then
                WindUI:Notify({
                    Title = "Auto Upgrade",
                    Content = "Please refresh and select brainrots first!",
                    Icon = "alert-triangle",
                    Duration = 3,
                })
                autoUpgradeBrainrot = false
            else
                WindUI:Notify({
                    Title = "Auto Upgrade",
                    Content = "Auto Upgrade enabled for " .. #upgradeBrainrotTargets .. " brainrot(s)",
                    Icon = "check",
                    Duration = 3,
                })
            end
        end
    end
})



-- ================= MISC TAB =================
local UISection = MiscTab:Section({
    Title = "UI Settings",
    Opened = true,
})

UISection:Toggle({
    Title = "Profile Icon",
    Desc = "Toggle profile visibility",
    Icon = "check",
    Value = true,
    Callback = function(state)
        local stateinfo = state
        if stateinfo then
            Window.User:Enable()
        else
            Window.User:Disable()
        end
    end
})

UISection:Toggle({
    Title = "Set Profile Anonymous",
    Desc = "Hide your profile information",
    Icon = "check",
    Value = false,
    Callback = function(state)
        local stateinfo = state
        if stateinfo then
            Window.User:SetAnonymous(true)
        else
            Window.User:SetAnonymous(false)
        end
    end
})

UISection:Toggle({
    Title = "UI Transparency",
    Desc = "Toggle window transparency",
    Icon = "check",
    Value = true,
    Callback = function(state)
        local stateinfo = state
        if stateinfo then
            Window:ToggleTransparency(true)
        else
            Window:ToggleTransparency(false)
        end
    end
})

UISection:Button({
    Title = "Reset Config",
    Desc = "Delete saved settings and reset to defaults",
    Callback = function()
        local filePath = "XuanHub/" .. settingsFileName
        if isfile(filePath) then
            delfile(filePath)
            WindUI:Notify({
                Title = "Config Reset",
                Content = "Config reset! Rejoin to take effect",
                Icon = "check",
                Duration = 5
            })
        else
            WindUI:Notify({
                Title = "Config Reset",
                Content = "No config file found",
                Icon = "info",
                Duration = 3
            })
        end
    end
})

local MiscSettings = MiscTab:Section({
    Title = "Game Settings",
    Opened = true,
})

-- Anti-AFK (Always On)
MiscSettings:Button({
    Title = "Anti-AFK (Always On)",
    Desc = "Prevents AFK kick - Always enabled",
    Callback = function()
        WindUI:Notify({ Title = "Info", Content = "Anti-AFK is always enabled", Icon = "info", Duration = 2 })
    end
})

MiscSettings:Space()

-- Auto Reconnect (Always On)
MiscSettings:Button({
    Title = "Auto Reconnect (Always On)",
    Desc = "Auto rejoin on disconnect - Always enabled",
    Callback = function()
        WindUI:Notify({ Title = "Info", Content = "Auto Reconnect is always enabled", Icon = "info", Duration = 2 })
    end
})

MiscTab:Space()
MiscTab:Space()

MiscTab:Section({
    Title = "Server Actions",
    Opened = true,
})

local ServerGroup = MiscTab:Group()

ServerGroup:Button({
    Title = "Server Hop",
    Icon = "solar:refresh-bold",
    Callback = function()
        Window:ServerHop()
    end


})

ServerGroup:Space()

ServerGroup:Button({
    Title = "Rejoin",
    Icon = "solar:restart-bold",
    Callback = function()
        game:GetService("TeleportService"):Teleport(game.PlaceId, player)
    end
})

-- ================= SETTINGS APPLY =================
task.spawn(function()
    task.wait(0.5) -- Wait for GUI to fully load

    -- Apply Auto Collect Money
    if savedSettings.autoCollectMoney then
        collectingMoney = true
    end

    -- Apply Auto Collect Radioactive
    if savedSettings.autoCollectRadioactive then
        active = true
    end

    -- Apply Auto Spin
    if savedSettings.autoSpin then
        spinning = true
    end

    -- Apply Auto Upgrade Base
    if savedSettings.autoUpgradeBase then
        autoUpgradeBase = true
    end

    -- Apply Auto Upgrade Carry
    if savedSettings.autoUpgradeCarry then
        autoUpgradeCarry = true
    end

    -- Apply Auto Upgrade Jump
    if savedSettings.autoUpgradeJump then
        autoUpgradeJump = true
    end

    -- Apply Auto Upgrade Speed
    if savedSettings.autoUpgradeSpeed then
        autoUpgradeSpeed = true
    end

    -- Apply Upgrade Speed Amount
    if savedSettings.upgradeSpeedAmount then
        upgradeSpeedAmount = savedSettings.upgradeSpeedAmount
    end

    -- Apply Auto Rebirth
    if savedSettings.autoRebirth then
        autoRebirth = true
    end

    -- Apply Auto Obby
    if savedSettings.autoObby then
        autoObby = true

        -- quick-start: try to interact with any existing obby using the resilient finder
        task.spawn(function()
            local root = findRadioactiveRoot()
            if root then
                local obbyEnd = root:FindFirstChild("ObbyEnd")
                if obbyEnd and humanoidRootPart then
                    pcall(function() firetouchinterest(humanoidRootPart, obbyEnd, 0) end)
                    task.wait()
                    pcall(function() firetouchinterest(humanoidRootPart, obbyEnd, 1) end)
                end
            end
        end)
    end

    -- Apply Auto Collect UFO
    if savedSettings.autoCollectUFO then
        autoCollectUFO = true
    end

    -- Apply Auto Collect Gold Bar (Money Event)
    if savedSettings.autoCollectGoldBar then
        autoCollectGoldBar = true
    end

    -- Apply Auto Complete Money Obby
    if savedSettings.autoCompleteMoneyObby then
        autoCompleteMoneyObby = true
    end

    -- Apply Auto Open Lucky Block
    if savedSettings.autoOpenLuckyBlock then
        autoOpenLuckyBlock = true
        autoOpenLuckyBlockTarget = tostring(savedSettings.autoOpenLuckyBlockTarget or autoOpenLuckyBlockTarget)
        autoOpenLuckyBlockDelay = tonumber(savedSettings.autoOpenLuckyBlockDelay) or autoOpenLuckyBlockDelay
    end

    -- Apply Auto Rejoin after Money Obby
    if savedSettings.autoRejoinAfterMoneyObby then
        autoRejoinAfterMoneyObby = true
    end

    -- Apply Auto Spin Money Wheel
    if savedSettings.autoSpinMoneyWheel then
        autoSpinMoneyWheel = true
    end

    -- Apply Auto Spin UFO Wheel
    if savedSettings.autoSpinUFO then
        autoSpinUFO = true
    end

    -- Apply Auto Collect Candy (Valentines Event)
    if savedSettings.autoCollectCandy then
        autoCollectCandy = true
    end

    -- Apply Auto Collect Valentines Coin
    if savedSettings.autoCollectValentinesCoin then
        autoCollectValentinesCoin = true
    end

    -- Apply Auto Spin Valentines Wheel
    if savedSettings.autoSpinValentinesWheel then
        autoSpinValentinesWheel = true
    end

    -- Apply God Mode
    if savedSettings.godMode then
        enableGodMode()
    end

    -- Apply Unlock Zoom
    if savedSettings.unlockZoom then
        enableUnlockZoom()
    end

    -- Apply Tsunami Tracker
    if savedSettings.autoTsunamiTracker then
        enableTsunamiTracker()
    end

    -- Apply Teleport-by-Rarity (Tsunami)
    if savedSettings.autoTeleportByRarity then
        autoTeleportByRarity = true
        autoTeleportByRarityTarget = tostring(savedSettings.autoTeleportByRarityTarget or "Common")
        -- start loop asynchronously (UI toggle removed — console/config controlled)
        task.spawn(function()
            -- reuse same logic as the runtime loop (non-blocking)
            if autoTeleportByRarity then
                _G.XuanHub_TeleportToRarity = _G.XuanHub_TeleportToRarity or function(r) end -- ensure exists
                _G.XuanHub_ToggleTeleportByRarity = _G.XuanHub_ToggleTeleportByRarity or function() end
            end
        end)
    end

    -- Apply Wider Hitbox
    if savedSettings.hitboxEnabled then
        widerHitboxWidth = tonumber(savedSettings.hitboxWidth) or 70
        startWiderHitbox()
    end

    -- Apply UI Settings
    task.wait(0.2)
    if savedSettings.profileIcon then
        Window.Icon:Enable()
    else
        Window.Icon:Disable()
    end

    if savedSettings.uiTransparency then
        Window:ToggleTransparency()
    end
end)

-- ================= MACHINE TAB =================
local DefaultMachineSection = MachineTab:Section({ Title = "Machine Section", Opened = true })

-- Create paragraph for Machine Luck Timer
local MachineLuckTimerParagraph = DefaultMachineSection:Paragraph({
    Title = "Machine Luck Timer",
    Desc = "Loading timer...",
})

-- Background loop to update Machine Luck Timer
local currentMachineTimer = "0.00"
task.spawn(function()
    while scriptRunning do
        pcall(function()
            local spawnMachines = workspace:FindFirstChild("SpawnMachines")
            if spawnMachines then
                local defaultMachine = spawnMachines:FindFirstChild("Default")
                if defaultMachine then
                    local main = defaultMachine:FindFirstChild("Main")
                    if main then
                        local billboard = main:FindFirstChild("Billboard")
                        if billboard then
                            local billboardGui = billboard:FindFirstChild("BillboardGui")
                            if billboardGui then
                                local frame = billboardGui:FindFirstChild("Frame")
                                if frame then
                                    local brainrots = frame:FindFirstChild("Brainrots")
                                    if brainrots then
                                        local afkLuckContainer = brainrots:FindFirstChild("AFKLuckContainer")
                                        if afkLuckContainer then
                                            local timeLabel = afkLuckContainer:FindFirstChild("TimeLabel")
                                            if timeLabel and timeLabel:IsA("TextLabel") then
                                                local timerText = timeLabel.Text
                                                currentMachineTimer = timerText
                                                MachineLuckTimerParagraph:SetDesc("Current Timer: " .. timerText)
                                            else
                                                MachineLuckTimerParagraph:SetDesc("TimeLabel not found")
                                            end
                                        else
                                            MachineLuckTimerParagraph:SetDesc("AFKLuckContainer not found")
                                        end
                                    else
                                        MachineLuckTimerParagraph:SetDesc("Brainrots not found")
                                    end
                                else
                                    MachineLuckTimerParagraph:SetDesc("Frame not found")
                                end
                            else
                                MachineLuckTimerParagraph:SetDesc("BillboardGui not found")
                            end
                        else
                            MachineLuckTimerParagraph:SetDesc("Billboard not found")
                        end
                    else
                        MachineLuckTimerParagraph:SetDesc("Main not found")
                    end
                else
                    MachineLuckTimerParagraph:SetDesc("Default machine not found")
                end
            else
                MachineLuckTimerParagraph:SetDesc("SpawnMachines not found")
            end
        end)
        task.wait(0.5)
    end
end)

-- Input for target time
DefaultMachineSection:Input({
    Title = "Target Time",
    Desc = "When machine timer matches this time, start fusion (format: MM:SS)",
    Value = "60:00",
    Placeholder = "Enter time (e.g., 60:00)",
    Callback = function(value)
        -- Validate time format (should contain ':')
        if value and value:match(":") then
            machineTargetTime = value
        else
            -- Default to 60:00 if invalid format
            machineTargetTime = "60:00"
            WindUI:Notify({
                Title = "Auto Machine",
                Content = "Invalid time format. Defaulted to 60:00",
                Icon =
                "alert-triangle",
                Duration = 3
            })
        end
    end
})

-- Get brainrot names once (called synchronously, uses cached data for subsequent calls)
local AllBrainrotNames = getBrainrotNamesForMachines()

-- Dropdown for Brainrot 1
DefaultMachineSection:Dropdown({
    Title = "Brainrot 1",
    Desc = "Select first brainrot to fuse/submit (shared for all machines)",
    Values = AllBrainrotNames,
    Value = "",
    Multi = false,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        machineBrainrot1 = option or ""
        arcadeBrainrot1 = option or ""
        valentineBrainrot1 = option or ""
    end
})

-- Dropdown for Brainrot 2
DefaultMachineSection:Dropdown({
    Title = "Brainrot 2",
    Desc = "Select second brainrot to fuse/submit (shared for all machines)",
    Values = AllBrainrotNames,
    Value = "",
    Multi = false,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        machineBrainrot2 = option or ""
        arcadeBrainrot2 = option or ""
        valentineBrainrot2 = option or ""
    end
})

-- Dropdown for Brainrot 3
DefaultMachineSection:Dropdown({
    Title = "Brainrot 3",
    Desc = "Select third brainrot to fuse/submit (shared for all machines)",
    Values = AllBrainrotNames,
    Value = "",
    Multi = false,
    AllowNone = true,
    SearchBarEnabled = true,
    Callback = function(option)
        machineBrainrot3 = option or ""
        arcadeBrainrot3 = option or ""
        valentineBrainrot3 = option or ""
    end
})

-- Toggle for Auto Machine
DefaultMachineSection:Toggle({
    Title = "Auto Machine (Default)",
    Desc = "Automatically fuse brainrots when timer matches target time",
    Icon = "check",
    Value = false,
    Callback = function(state)
        autoMachine = state
        if state then
            WindUI:Notify({ Title = "Auto Machine", Content = "Auto machine enabled", Icon = "check", Duration = 3 })
        else
            WindUI:Notify({ Title = "Auto Machine", Content = "Auto machine disabled", Icon = "check", Duration = 3 })
        end
    end
})

-- Toggle for Auto Submit to Arcade Machine
DefaultMachineSection:Toggle({
    Title = "Auto Submit (Arcade)",
    Desc = "Automatically navigate through gaps and submit brainrots to Arcade Machine",
    Icon = "check",
    Value = false,
    Callback = function(state)
        autoArcadeMachine = state
        if state then
            _G.ArcadeAutoSubmitActive = true
            WindUI:Notify({ Title = "Arcade Machine", Content = "Auto submit enabled", Icon = "check", Duration = 3 })
        else
            _G.ArcadeAutoSubmitActive = false
            WindUI:Notify({ Title = "Arcade Machine", Content = "Auto submit disabled", Icon = "check", Duration = 3 })
        end
    end
})

-- Toggle for Auto Submit to Valentine Machine
DefaultMachineSection:Toggle({
    Title = "Auto Submit (Valentine)",
    Desc = "Automatically navigate through gaps and submit brainrots to Valentine Machine",
    Icon = "check",
    Value = false,
    Callback = function(state)
        autoValentineMachine = state
        if state then
            _G.ValentineAutoSubmitActive = true
            WindUI:Notify({ Title = "Valentine Machine", Content = "Auto submit enabled", Icon = "check", Duration = 3 })
        else
            _G.ValentineAutoSubmitActive = false
            WindUI:Notify({ Title = "Valentine Machine", Content = "Auto submit disabled", Icon = "check", Duration = 3 })
        end
    end
})

-- Helper function to find and equip tool from backpack
local function equipBrainrotTool(brainrotName)
    local backpack = player:FindFirstChild("Backpack")
    local character = player.Character
    if not backpack or not character then return false end

    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return false end

    for _, tool in ipairs(backpack:GetChildren()) do
        if tool:IsA("Tool") then
            local toolBrainrotName = tool:GetAttribute("BrainrotName")
            if toolBrainrotName and toolBrainrotName == brainrotName then
                humanoid:EquipTool(tool)
                task.wait(0.3)
                return true
            end
        end
    end
    return false
end

-- Helper function to deposit brainrot
local function depositBrainrot()
    local defaultMachine = workspace:FindFirstChild("SpawnMachines") and
        workspace.SpawnMachines:FindFirstChild("Default")
    if not defaultMachine then return false end

    local args = {
        "Deposit",
        defaultMachine
    }
    local ok = pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
            "RF/SpawnMachine.Action"):InvokeServer(unpack(args))
    end)
    task.wait(0.5)
    return ok
end

-- Helper function to combine brainrots
local function combineBrainrots()
    local defaultMachine = workspace:FindFirstChild("SpawnMachines") and
        workspace.SpawnMachines:FindFirstChild("Default")
    if not defaultMachine then return false end

    local args = {
        "Combine",
        defaultMachine
    }
    local ok = pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
            "RF/SpawnMachine.Action"):InvokeServer(unpack(args))
    end)
    task.wait(0.5)
    return ok
end

-- Helper function to teleport to machine
local function teleportToMachine()
    local defaultMachine = workspace:FindFirstChild("SpawnMachines") and
        workspace.SpawnMachines:FindFirstChild("Default")
    if not defaultMachine then return false end

    local targetPart = defaultMachine:GetChildren()[18]
    if not targetPart or not targetPart:IsA("BasePart") then return false end

    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    pcall(function()
        hrp.CFrame = targetPart.CFrame + Vector3.new(0, 3, 0)
    end)
    task.wait(0.3)
    return true
end

-- Auto Machine Background Loop
task.spawn(function()
    while scriptRunning do
        if autoMachine then
            pcall(function()
                -- Check if timer matches target time
                if currentMachineTimer == machineTargetTime then
                    WindUI:Notify({ Title = "Auto Machine", Content = "Timer matched! Starting fusion...", Icon = "info", Duration = 3 })

                    -- Step 1: Teleport to machine
                    if not teleportToMachine() then
                        WindUI:Notify({
                            Title = "Auto Machine",
                            Content = "Failed to teleport to machine",
                            Icon =
                            "alert-triangle",
                            Duration = 3
                        })
                        autoMachine = false
                    else
                        local depositSuccess = true

                        -- Step 2: Deposit Brainrot 1 (if selected)
                        if machineBrainrot1 ~= "" then
                            if not equipBrainrotTool(machineBrainrot1) then
                                WindUI:Notify({
                                    Title = "Auto Machine",
                                    Content = "Brainrot 1 not found: " ..
                                        machineBrainrot1,
                                    Icon = "alert-triangle",
                                    Duration = 3
                                })
                                depositSuccess = false
                            elseif not depositBrainrot() then
                                WindUI:Notify({
                                    Title = "Auto Machine",
                                    Content = "Failed to deposit Brainrot 1",
                                    Icon =
                                    "alert-triangle",
                                    Duration = 3
                                })
                                depositSuccess = false
                            end
                        end

                        -- Step 3: Deposit Brainrot 2 (if selected and previous steps succeeded)
                        if depositSuccess and machineBrainrot2 ~= "" then
                            if not equipBrainrotTool(machineBrainrot2) then
                                WindUI:Notify({
                                    Title = "Auto Machine",
                                    Content = "Brainrot 2 not found: " ..
                                        machineBrainrot2,
                                    Icon = "alert-triangle",
                                    Duration = 3
                                })
                                depositSuccess = false
                            elseif not depositBrainrot() then
                                WindUI:Notify({
                                    Title = "Auto Machine",
                                    Content = "Failed to deposit Brainrot 2",
                                    Icon =
                                    "alert-triangle",
                                    Duration = 3
                                })
                                depositSuccess = false
                            end
                        end

                        -- Step 4: Deposit Brainrot 3 (if selected and previous steps succeeded)
                        if depositSuccess and machineBrainrot3 ~= "" then
                            if not equipBrainrotTool(machineBrainrot3) then
                                WindUI:Notify({
                                    Title = "Auto Machine",
                                    Content = "Brainrot 3 not found: " ..
                                        machineBrainrot3,
                                    Icon = "alert-triangle",
                                    Duration = 3
                                })
                                depositSuccess = false
                            elseif not depositBrainrot() then
                                WindUI:Notify({
                                    Title = "Auto Machine",
                                    Content = "Failed to deposit Brainrot 3",
                                    Icon =
                                    "alert-triangle",
                                    Duration = 3
                                })
                                depositSuccess = false
                            end
                        end

                        -- Step 5: Combine (only if at least one brainrot was deposited successfully)
                        if depositSuccess then
                            if not combineBrainrots() then
                                WindUI:Notify({
                                    Title = "Auto Machine",
                                    Content = "Failed to combine brainrots",
                                    Icon =
                                    "alert-triangle",
                                    Duration = 3
                                })
                                autoMachine = false
                            else
                                WindUI:Notify({
                                    Title = "Auto Machine",
                                    Content =
                                    "Fusion completed! Waiting 30s for cooldown...",
                                    Icon = "check",
                                    Duration = 3
                                })
                                task.wait(30)
                            end
                        else
                            autoMachine = false
                        end
                    end
                end
            end)
            task.wait(1)
        else
            task.wait(1)
        end
    end
end)

-- Helper function to find Arcade gaps folder
local function findArcadeGapsFolder()
    local arcadeMap = workspace:FindFirstChild("ArcadeMap")
    if not arcadeMap then return nil end
    
    local gaps = arcadeMap:FindFirstChild("Gaps")
    if not gaps then return nil end
    
    return gaps
end

-- Helper function to check if player is alive
local function isPlayerAlive()
    local character = player.Character
    if not character then return false end
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    return true
end

-- Helper function to teleport to Arcade gap
local function teleportToArcadeGap(gapNumber)
    local gapsFolder = findArcadeGapsFolder()
    if not gapsFolder then return false end

    local gapName = "Gap" .. tostring(gapNumber)
    local gap = gapsFolder:FindFirstChild(gapName)
    if not gap then return false end

    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    -- Get gap position - prioritize Mud part
    local targetPos

    -- Try to find Mud part first
    local mudPart = gap:FindFirstChild("Mud")
    if mudPart and mudPart:IsA("BasePart") then
        targetPos = mudPart.Position
    elseif gap:IsA("BasePart") then
        targetPos = gap.Position
    elseif gap:IsA("Model") then
        local primaryPart = gap.PrimaryPart or gap:FindFirstChildWhichIsA("BasePart")
        if primaryPart then
            targetPos = primaryPart.Position
        end
    end

    if not targetPos then return false end

    -- Offset position above the mud to prevent falling
    targetPos = targetPos + Vector3.new(0, 3, 0)

    -- Check if path is clear (no tsunami)
    if not IsPathClear(targetPos) then
        return false
    end

    -- Instant teleport to gap (no tween)
    pcall(function()
        hrp.CFrame = CFrame.new(targetPos)
    end)
    task.wait(0.2)
    return true
end

-- Helper function to teleport to Arcade Machine
local function teleportToArcadeMachine()
    local spawnMachines = workspace:FindFirstChild("SpawnMachines")
    if not spawnMachines then return false end

    local arcadeMachine = spawnMachines:FindFirstChild("Arcade")
    if not arcadeMachine then return false end

    local model = arcadeMachine:FindFirstChild("Model")
    if not model then return false end

    local targetPart = model:FindFirstChild("Part")
    if not targetPart or not targetPart:IsA("BasePart") then return false end

    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    pcall(function()
        hrp.CFrame = targetPart.CFrame + Vector3.new(0, 3, 0)
    end)
    task.wait(0.3)
    return true
end

-- Helper function to deposit brainrot to Arcade
local function depositArcadeBrainrot()
    local ok = pcall(function()
        local args = {
            "Deposit",
            workspace:WaitForChild("SpawnMachines"):WaitForChild("Arcade")
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
        "RF/SpawnMachine.Action"):InvokeServer(unpack(args))
    end)
    task.wait(0.5)
    return ok
end

-- Helper function to combine brainrots in Arcade
local function combineArcadeBrainrots()
    local ok = pcall(function()
        local args = {
            "Combine",
            workspace:WaitForChild("SpawnMachines"):WaitForChild("Arcade")
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
        "RF/SpawnMachine.Action"):InvokeServer(unpack(args))
    end)
    task.wait(0.5)
    return ok
end

-- Auto Arcade Machine Background Loop
task.spawn(function()
    while scriptRunning do
        if autoArcadeMachine and _G.ArcadeAutoSubmitActive then
            pcall(function()
                -- Check if player is alive
                if not isPlayerAlive() then
                    WindUI:Notify({ Title = "Arcade Machine", Content = "Player died - stopping auto submit", Icon =
                    "alert-triangle", Duration = 3 })
                    autoArcadeMachine = false
                    _G.ArcadeAutoSubmitActive = false
                    return
                end

                WindUI:Notify({ Title = "Arcade Machine", Content = "Starting gap progression...", Icon = "info", Duration = 3 })

                -- Teleport through gaps 1-5
                local gapSuccess = true
                for gapNum = 1, 5 do
                    if not _G.ArcadeAutoSubmitActive or not isPlayerAlive() then
                        WindUI:Notify({ Title = "Arcade Machine", Content = "Stopped during gap teleport", Icon =
                        "alert-triangle", Duration = 3 })
                        autoArcadeMachine = false
                        _G.ArcadeAutoSubmitActive = false
                        return
                    end

                    -- Try to teleport to gap
                    local maxRetries = 10
                    local retryCount = 0
                    local teleported = false

                    while retryCount < maxRetries and not teleported and _G.ArcadeAutoSubmitActive do
                        teleported = teleportToArcadeGap(gapNum)
                        if not teleported then
                            -- Gap blocked by tsunami, wait at Gap 5 if we're past it
                            if gapNum > 1 then
                                WindUI:Notify({ Title = "Arcade Machine", Content = "Gap " ..
                                gapNum .. " blocked - returning to Gap 5", Icon = "alert-triangle", Duration = 3 })
                                teleportToArcadeGap(5)
                                task.wait(2)
                            else
                                task.wait(1)
                            end
                            retryCount = retryCount + 1
                        end
                    end

                    if not teleported then
                        WindUI:Notify({ Title = "Arcade Machine", Content = "Failed to reach Gap " .. gapNum, Icon =
                        "alert-triangle", Duration = 3 })
                        gapSuccess = false
                        break
                    end

                    WindUI:Notify({ Title = "Arcade Machine", Content = "Reached Gap " .. gapNum, Icon = "check", Duration = 2 })
                end

                -- Check if we successfully reached Gap 5
                if not gapSuccess or not _G.ArcadeAutoSubmitActive or not isPlayerAlive() then
                    autoArcadeMachine = false
                    _G.ArcadeAutoSubmitActive = false
                    return
                end

                -- Continuous deposit and combine loop
                while _G.ArcadeAutoSubmitActive and isPlayerAlive() do
                    -- Make sure we're at Gap 5
                    teleportToArcadeGap(5)
                    task.wait(0.5)
                    
                    -- Check if path from Gap 5 to Arcade Machine (Gap 5 to 6) is safe
                    local arcadeMachine = workspace:FindFirstChild("SpawnMachines") and
                        workspace.SpawnMachines:FindFirstChild("Arcade")
                    local pathIsSafe = false

                    if arcadeMachine then
                        local model = arcadeMachine:FindFirstChild("Model")
                        if model then
                            local targetPart = model:FindFirstChild("Part")
                            if targetPart then
                                local targetPos = targetPart.Position + Vector3.new(0, 3, 0)

                                -- Wait at Gap 5 until path is clear
                                while not IsPathClear(targetPos) and _G.ArcadeAutoSubmitActive and isPlayerAlive() do
                                    WindUI:Notify({ Title = "Arcade Machine", Content =
                                    "Gap 5 to machine blocked! Waiting at Gap 5...", Icon = "alert-triangle", Duration = 3 })
                                    teleportToArcadeGap(5)
                                    task.wait(2)
                                end

                                if _G.ArcadeAutoSubmitActive and isPlayerAlive() then
                                    WindUI:Notify({ Title = "Arcade Machine", Content =
                                    "Path is safe! Moving to machine...", Icon = "check", Duration = 3 })
                                    pathIsSafe = true
                                end
                            end
                        end
                    end

                    -- If path is not safe or check failed, stop
                    if not pathIsSafe or not _G.ArcadeAutoSubmitActive or not isPlayerAlive() then
                        break
                    end

                    -- Teleport to Arcade Machine
                    if not teleportToArcadeMachine() then
                        WindUI:Notify({ Title = "Arcade Machine", Content = "Failed to teleport to machine", Icon =
                        "alert-triangle", Duration = 3 })
                        task.wait(2)
                    else
                        WindUI:Notify({ Title = "Arcade Machine", Content = "At Arcade Machine - depositing...", Icon =
                        "info", Duration = 2 })
                        task.wait(1)

                        -- Deposit brainrots
                        local depositSuccess = true

                        -- Deposit Brainrot 1
                        if arcadeBrainrot1 ~= "" and _G.ArcadeAutoSubmitActive then
                            if not equipBrainrotTool(arcadeBrainrot1) then
                                WindUI:Notify({ Title = "Arcade Machine", Content = "Brainrot 1 not found: " ..
                                arcadeBrainrot1, Icon = "alert-triangle", Duration = 3 })
                                depositSuccess = false
                            elseif not depositArcadeBrainrot() then
                                WindUI:Notify({ Title = "Arcade Machine", Content = "Failed to deposit Brainrot 1", Icon =
                                "alert-triangle", Duration = 3 })
                                depositSuccess = false
                            else
                                WindUI:Notify({ Title = "Arcade Machine", Content = "Deposited Brainrot 1", Icon =
                                "check", Duration = 2 })
                            end
                        end

                        -- Deposit Brainrot 2
                        if depositSuccess and arcadeBrainrot2 ~= "" and _G.ArcadeAutoSubmitActive then
                            if not equipBrainrotTool(arcadeBrainrot2) then
                                WindUI:Notify({ Title = "Arcade Machine", Content = "Brainrot 2 not found: " ..
                                arcadeBrainrot2, Icon = "alert-triangle", Duration = 3 })
                                depositSuccess = false
                            elseif not depositArcadeBrainrot() then
                                WindUI:Notify({ Title = "Arcade Machine", Content = "Failed to deposit Brainrot 2", Icon =
                                "alert-triangle", Duration = 3 })
                                depositSuccess = false
                            else
                                WindUI:Notify({ Title = "Arcade Machine", Content = "Deposited Brainrot 2", Icon =
                                "check", Duration = 2 })
                            end
                        end

                        -- Deposit Brainrot 3
                        if depositSuccess and arcadeBrainrot3 ~= "" and _G.ArcadeAutoSubmitActive then
                            if not equipBrainrotTool(arcadeBrainrot3) then
                                WindUI:Notify({ Title = "Arcade Machine", Content = "Brainrot 3 not found: " ..
                                arcadeBrainrot3, Icon = "alert-triangle", Duration = 3 })
                                depositSuccess = false
                            elseif not depositArcadeBrainrot() then
                                WindUI:Notify({ Title = "Arcade Machine", Content = "Failed to deposit Brainrot 3", Icon =
                                "alert-triangle", Duration = 3 })
                                depositSuccess = false
                            else
                                WindUI:Notify({ Title = "Arcade Machine", Content = "Deposited Brainrot 3", Icon =
                                "check", Duration = 2 })
                            end
                        end

                        -- Combine brainrots
                        if depositSuccess and _G.ArcadeAutoSubmitActive then
                            if not combineArcadeBrainrots() then
                                WindUI:Notify({ Title = "Arcade Machine", Content = "Failed to combine brainrots", Icon =
                                "alert-triangle", Duration = 3 })
                            else
                                WindUI:Notify({ Title = "Arcade Machine", Content =
                                "Successfully combined!", Icon = "check", Duration = 3 })
                                
                                -- Return to Gap 5 after combining
                                task.wait(1)
                                teleportToArcadeGap(5)
                                WindUI:Notify({ Title = "Arcade Machine", Content =
                                "Returned to Gap 5. Waiting 31s for cooldown...", Icon = "info", Duration = 3 })
                                
                                -- Wait 31 seconds for machine cooldown (30s + 1s buffer)
                                task.wait(31)
                                
                                WindUI:Notify({ Title = "Arcade Machine", Content =
                                "Cooldown complete! Continuing loop...", Icon = "check", Duration = 3 })
                            end
                        end
                    end
                end

                -- Loop ended
                WindUI:Notify({ Title = "Arcade Machine", Content = "Auto submit loop ended", Icon = "info", Duration = 3 })
            end)
        end
        task.wait(1)
    end
end)

-- Death detection for Arcade auto-submit
player.CharacterAdded:Connect(function(char)
    local humanoid = char:WaitForChild("Humanoid")
    humanoid.Died:Connect(function()
        if _G.ArcadeAutoSubmitActive then
            _G.ArcadeAutoSubmitActive = false
            autoArcadeMachine = false
            WindUI:Notify({ Title = "Arcade Machine", Content = "Player died - auto submit stopped", Icon =
            "alert-triangle", Duration = 3 })
        end
    end)
end)

-- Also set up death detection for current character if it exists
if player.Character then
    local humanoid = player.Character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.Died:Connect(function()
            if _G.ArcadeAutoSubmitActive then
                _G.ArcadeAutoSubmitActive = false
                autoArcadeMachine = false
                WindUI:Notify({ Title = "Arcade Machine", Content = "Player died - auto submit stopped", Icon =
                "alert-triangle", Duration = 3 })
            end
        end)
    end
end

-- Helper function to find Valentine gaps folder
local function findValentineGapsFolder()
    local valentineMap = workspace:FindFirstChild("ValentinesMap_SharedInstances")
    if not valentineMap then return nil end
    
    local gaps = valentineMap:FindFirstChild("Gaps")
    if not gaps then return nil end
    
    return gaps
end

-- Helper function to teleport to Valentine gap
local function teleportToValentineGap(gapNumber)
    local gapsFolder = findValentineGapsFolder()
    if not gapsFolder then return false end

    local gapName = "Gap" .. tostring(gapNumber)
    local gap = gapsFolder:FindFirstChild(gapName)
    if not gap then return false end

    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    -- Get gap position
    local targetPos

    if gap:IsA("BasePart") then
        targetPos = gap.Position
    elseif gap:IsA("Model") then
        local primaryPart = gap.PrimaryPart or gap:FindFirstChildWhichIsA("BasePart")
        if primaryPart then
            targetPos = primaryPart.Position
        end
    end

    if not targetPos then return false end

    -- Offset position above the gap
    targetPos = targetPos + Vector3.new(0, 3, 0)

    -- Check if path is clear (no tsunami)
    if not IsPathClear(targetPos) then
        return false
    end

    -- Instant teleport to gap
    pcall(function()
        hrp.CFrame = CFrame.new(targetPos)
    end)
    task.wait(0.2)
    return true
end

-- Helper function to teleport to Valentine Machine
local function teleportToValentineMachine()
    local spawnMachines = workspace:FindFirstChild("SpawnMachines")
    if not spawnMachines then return false end

    local valentineMachine = spawnMachines:FindFirstChild("Valentines")
    if not valentineMachine then return false end

    local promptZone = valentineMachine:FindFirstChild("PromptZone")
    if not promptZone then return false end

    local radius = promptZone:FindFirstChild("Radius")
    if not radius or not radius:IsA("BasePart") then return false end

    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    pcall(function()
        hrp.CFrame = radius.CFrame + Vector3.new(0, 3, 0)
    end)
    task.wait(0.3)
    return true
end

-- Helper function to deposit brainrot to Valentine
local function depositValentineBrainrot()
    local ok = pcall(function()
        local args = {
            "Deposit",
            workspace:WaitForChild("SpawnMachines"):WaitForChild("Valentines")
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
        "RF/SpawnMachine.Action"):InvokeServer(unpack(args))
    end)
    task.wait(0.5)
    return ok
end

-- Helper function to combine brainrots in Valentine
local function combineValentineBrainrots()
    local ok = pcall(function()
        local args = {
            "Combine",
            workspace:WaitForChild("SpawnMachines"):WaitForChild("Valentines")
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Net"):WaitForChild(
        "RF/SpawnMachine.Action"):InvokeServer(unpack(args))
    end)
    task.wait(0.5)
    return ok
end

-- Auto Valentine Machine Background Loop
task.spawn(function()
    while scriptRunning do
        if autoValentineMachine and _G.ValentineAutoSubmitActive then
            pcall(function()
                -- Check if player is alive
                if not isPlayerAlive() then
                    WindUI:Notify({ Title = "Valentine Machine", Content = "Player died - stopping auto submit", Icon =
                    "alert-triangle", Duration = 3 })
                    autoValentineMachine = false
                    _G.ValentineAutoSubmitActive = false
                    return
                end

                WindUI:Notify({ Title = "Valentine Machine", Content = "Starting gap progression...", Icon = "info", Duration = 3 })

                -- Teleport through gaps 1-5
                local gapSuccess = true
                for gapNum = 1, 5 do
                    if not _G.ValentineAutoSubmitActive or not isPlayerAlive() then
                        WindUI:Notify({ Title = "Valentine Machine", Content = "Stopped during gap teleport", Icon =
                        "alert-triangle", Duration = 3 })
                        autoValentineMachine = false
                        _G.ValentineAutoSubmitActive = false
                        return
                    end

                    -- Try to teleport to gap
                    local maxRetries = 10
                    local retryCount = 0
                    local teleported = false

                    while retryCount < maxRetries and not teleported and _G.ValentineAutoSubmitActive do
                        teleported = teleportToValentineGap(gapNum)
                        if not teleported then
                            -- Gap blocked by tsunami, wait at Gap 5 if we're past it
                            if gapNum > 1 then
                                WindUI:Notify({ Title = "Valentine Machine", Content = "Gap " ..
                                gapNum .. " blocked - returning to Gap 5", Icon = "alert-triangle", Duration = 3 })
                                teleportToValentineGap(5)
                                task.wait(2)
                            else
                                task.wait(1)
                            end
                            retryCount = retryCount + 1
                        end
                    end

                    if not teleported then
                        WindUI:Notify({ Title = "Valentine Machine", Content = "Failed to reach Gap " .. gapNum, Icon =
                        "alert-triangle", Duration = 3 })
                        gapSuccess = false
                        break
                    end

                    WindUI:Notify({ Title = "Valentine Machine", Content = "Reached Gap " .. gapNum, Icon = "check", Duration = 2 })
                end

                -- Check if we successfully reached Gap 5
                if not gapSuccess or not _G.ValentineAutoSubmitActive or not isPlayerAlive() then
                    autoValentineMachine = false
                    _G.ValentineAutoSubmitActive = false
                    return
                end

                -- Continuous deposit and combine loop at Gap 5
                while _G.ValentineAutoSubmitActive and isPlayerAlive() do
                    -- Make sure we're at Gap 5
                    teleportToValentineGap(5)
                    task.wait(0.5)
                    
                    -- Check if path from Gap 5 to Valentine Machine is safe
                    local valentineMachine = workspace:FindFirstChild("SpawnMachines") and
                        workspace.SpawnMachines:FindFirstChild("Valentines")
                    local pathIsSafe = false

                    if valentineMachine then
                        local promptZone = valentineMachine:FindFirstChild("PromptZone")
                        if promptZone then
                            local radius = promptZone:FindFirstChild("Radius")
                            if radius then
                                local targetPos = radius.Position + Vector3.new(0, 3, 0)

                                -- Wait at Gap 5 until path is clear
                                while not IsPathClear(targetPos) and _G.ValentineAutoSubmitActive and isPlayerAlive() do
                                    WindUI:Notify({ Title = "Valentine Machine", Content =
                                    "Gap 5 to machine blocked! Waiting at Gap 5...", Icon = "alert-triangle", Duration = 3 })
                                    teleportToValentineGap(5)
                                    task.wait(2)
                                end

                                if _G.ValentineAutoSubmitActive and isPlayerAlive() then
                                    WindUI:Notify({ Title = "Valentine Machine", Content =
                                    "Path is safe! Moving to machine...", Icon = "check", Duration = 3 })
                                    pathIsSafe = true
                                end
                            end
                        end
                    end

                    -- If path is not safe or check failed, break loop
                    if not pathIsSafe or not _G.ValentineAutoSubmitActive or not isPlayerAlive() then
                        break
                    end

                    -- Teleport to Valentine Machine (PromptZone.Radius)
                    if not teleportToValentineMachine() then
                        WindUI:Notify({ Title = "Valentine Machine", Content = "Failed to teleport to machine", Icon =
                        "alert-triangle", Duration = 3 })
                        task.wait(2)
                    else
                        WindUI:Notify({ Title = "Valentine Machine", Content = "At Valentine Machine - depositing...", Icon =
                        "info", Duration = 2 })
                        task.wait(1)

                        -- Deposit brainrots
                        local depositSuccess = true

                        -- Deposit Brainrot 1
                        if valentineBrainrot1 ~= "" and _G.ValentineAutoSubmitActive then
                            if not equipBrainrotTool(valentineBrainrot1) then
                                WindUI:Notify({ Title = "Valentine Machine", Content = "Brainrot 1 not found: " ..
                                valentineBrainrot1, Icon = "alert-triangle", Duration = 3 })
                                depositSuccess = false
                            elseif not depositValentineBrainrot() then
                                WindUI:Notify({ Title = "Valentine Machine", Content = "Failed to deposit Brainrot 1", Icon =
                                "alert-triangle", Duration = 3 })
                                depositSuccess = false
                            else
                                WindUI:Notify({ Title = "Valentine Machine", Content = "Deposited Brainrot 1", Icon =
                                "check", Duration = 2 })
                            end
                        end

                        -- Deposit Brainrot 2
                        if depositSuccess and valentineBrainrot2 ~= "" and _G.ValentineAutoSubmitActive then
                            if not equipBrainrotTool(valentineBrainrot2) then
                                WindUI:Notify({ Title = "Valentine Machine", Content = "Brainrot 2 not found: " ..
                                valentineBrainrot2, Icon = "alert-triangle", Duration = 3 })
                                depositSuccess = false
                            elseif not depositValentineBrainrot() then
                                WindUI:Notify({ Title = "Valentine Machine", Content = "Failed to deposit Brainrot 2", Icon =
                                "alert-triangle", Duration = 3 })
                                depositSuccess = false
                            else
                                WindUI:Notify({ Title = "Valentine Machine", Content = "Deposited Brainrot 2", Icon =
                                "check", Duration = 2 })
                            end
                        end

                        -- Deposit Brainrot 3
                        if depositSuccess and valentineBrainrot3 ~= "" and _G.ValentineAutoSubmitActive then
                            if not equipBrainrotTool(valentineBrainrot3) then
                                WindUI:Notify({ Title = "Valentine Machine", Content = "Brainrot 3 not found: " ..
                                valentineBrainrot3, Icon = "alert-triangle", Duration = 3 })
                                depositSuccess = false
                            elseif not depositValentineBrainrot() then
                                WindUI:Notify({ Title = "Valentine Machine", Content = "Failed to deposit Brainrot 3", Icon =
                                "alert-triangle", Duration = 3 })
                                depositSuccess = false
                            else
                                WindUI:Notify({ Title = "Valentine Machine", Content = "Deposited Brainrot 3", Icon =
                                "check", Duration = 2 })
                            end
                        end

                        -- Combine brainrots
                        if depositSuccess and _G.ValentineAutoSubmitActive then
                            if not combineValentineBrainrots() then
                                WindUI:Notify({ Title = "Valentine Machine", Content = "Failed to combine brainrots", Icon =
                                "alert-triangle", Duration = 3 })
                            else
                                WindUI:Notify({ Title = "Valentine Machine", Content =
                                "Successfully combined!", Icon = "check", Duration = 3 })
                                
                                -- Return to Gap 5 after combining
                                task.wait(1)
                                teleportToValentineGap(5)
                                WindUI:Notify({ Title = "Valentine Machine", Content =
                                "Returned to Gap 5. Waiting 31s for cooldown...", Icon = "info", Duration = 3 })
                                
                                -- Wait 31 seconds for machine cooldown (30s + 1s buffer)
                                task.wait(31)
                                
                                WindUI:Notify({ Title = "Valentine Machine", Content =
                                "Cooldown complete! Checking path again...", Icon = "check", Duration = 3 })
                            end
                        end
                    end
                end

                -- Loop ended
                WindUI:Notify({ Title = "Valentine Machine", Content = "Auto submit stopped", Icon = "info", Duration = 3 })
            end)
        end
        task.wait(1)
    end
end)

-- Death detection for Valentine auto-submit
player.CharacterAdded:Connect(function(char)
    local humanoid = char:WaitForChild("Humanoid")
    humanoid.Died:Connect(function()
        if _G.ValentineAutoSubmitActive then
            _G.ValentineAutoSubmitActive = false
            autoValentineMachine = false
            WindUI:Notify({ Title = "Valentine Machine", Content = "Player died - auto submit stopped", Icon =
            "alert-triangle", Duration = 3 })
        end
    end)
end)

-- Also set up death detection for current character if it exists
if player.Character then
    local humanoid = player.Character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.Died:Connect(function()
            if _G.ValentineAutoSubmitActive then
                _G.ValentineAutoSubmitActive = false
                autoValentineMachine = false
                WindUI:Notify({ Title = "Valentine Machine", Content = "Player died - auto submit stopped", Icon =
                "alert-triangle", Duration = 3 })
            end
        end)
    end
end

-- ================= ABOUT TAB =================
local DiscordTitle = AboutTab:Paragraph({
    Title = gradient("Discord", Color3.fromHex("#25fa00"), Color3.fromHex("#25fa00")),
    Desc = "Join our Discord for updates, giveaways, questions, support and more!",
    TextXAlignment = "Center",
    TextSize = 17,
})

AboutTab:Divider()

local InviteCode = "kaydensdens"
local DiscordAPI = ("https://discord.com/api/v10/invites/%s?with_counts=true&with_expiration=true"):format(InviteCode)

local function GetDiscordData()
    local success, result = pcall(function()
        local response = WindUI.Creator.Request({
            Url = DiscordAPI,
            Method = "GET",
            Headers = {
                ["User-Agent"] = "RobloxBot/1.0",
                ["Accept"] = "application/json"
            }
        })
        return HttpService:JSONDecode(response.Body)
    end)
    return success, result
end

local success, result = GetDiscordData()

if success and result and result.guild then
    local DiscordInfo = AboutTab:Paragraph({
        Title = result.guild.name or "Unknown Server",
        Desc = string.format(
            ' <font color="#52525b">•</font> Member Count : %d\n <font color="#16a34a">•</font> Online Count : %d',
            result.approximate_member_count or 0,
            result.approximate_presence_count or 0
        ),
        Image = string.format(
            "https://cdn.discordapp.com/icons/%s/%s.png?size=1024",
            result.guild.id,
            result.guild.icon
        ),
        ImageSize = 42,
    })

    AboutTab:Button({
        Title = "Copy Discord Invite",
        Callback = function()
            if setclipboard then
                setclipboard("https://discord.gg/" .. InviteCode)
                WindUI:Notify({ Title = "Discord", Content = "Invite link copied!", Icon = "check", Duration = 2 })
            else
                warn("setclipboard() not available in this environment.")
                WindUI:Notify({ Title = "Discord", Content = "Clipboard not supported", Icon = "alert-triangle", Duration = 2 })
            end
        end
    })
else
    AboutTab:Paragraph({
        Title = "Error fetching Discord Info",
        Desc = HttpService:JSONEncode(result or { error = "Unknown error" }),
        Image = "triangle-alert",
        ImageSize = 26,
        Color = "Red",
    })
end

-- Set Base tab as default
AboutTab:Select()

-- ================= FINALIZE =================
WindUI:Notify({
    Title = "Xuan Hub Loaded",
    Content = "Welcome " .. player.DisplayName .. "!",
    Icon = "check",
    Duration = 5,
})

print("--===== XUAN HUB READY =====--")
